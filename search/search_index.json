{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u5199\u5728\u524d\u9762\u7684\u8bdd \u4f5c\u4e3a\u4e00\u540d\u5927\u4e09\u5b66\u751f\uff0c\u6211\u5c1d\u8bd5\u5199\u4e0b\u8fd9\u4efd\u6587\u6863\uff0c\u4e00\u65b9\u9762\u662f\u7ed9\u6700\u8fd1\u8fd9\u6bb5\u6e38\u620f\u5f15\u64ce\u5b66\u4e60\u7ecf\u5386\u4e00\u4e2a\u603b\u7ed3\uff0c\u540c\u65f6\u8fd9\u4e5f\u5c06\u6210\u4e3a\u6211\u6bd5\u8bbe\u7684\u4e00\u90e8\u5206\uff1b\u53e6\u4e00\u65b9\u9762\u662f\u60f3\u7ed9\u540e\u6765\u8005\u6307\u4e00\u6307\u5927\u6982\u7684\u65b9\u5411\u3002 \u5e0c\u671b\u80fd\u6709\u8d8a\u6765\u8d8a\u591a\u7684\u4eba\u70ed\u7231\u6e38\u620f\u5f15\u64ce\uff0c\u4e86\u89e3\u5b83\uff0c\u7136\u540e\u4f18\u5316\u5b83\uff0c\u4e89\u53d6\u65e9\u65e5\u5b9e\u73b0\u300a\u9ed1\u5ba2\u5e1d\u56fd\u300b\u4e2d\u7684\u573a\u666f\u3002 \u82f1\u6587\u7248 \u7684\u4f1a\u968f\u7740\u8be5\u6587\u6863\u7f13\u6162\u66f4\u65b0\u3002 \u5982\u679c\u4f60\u5728\u9605\u8bfb\u671f\u95f4\u6709\u4efb\u4f55\u95ee\u9898\uff0c\u53ef\u4ee5\u5728\u8be5\u9879\u76ee\u7684 Github \u5730\u5740 \u63d0\u4ea4 issue \u6216\u8005\u5411 2481814748@qq.com \u53d1\u9001\u90ae\u4ef6\uff0c\u6211\u5c06\u4f1a\u975e\u5e38\u611f\u8c22\u60a8\u63d0\u4f9b\u7684\u5b9d\u8d35\u610f\u89c1\u3002 \u6b22\u8fce\u6765\u5230\u6e38\u620f\u5f15\u64ce\u7684\u4e16\u754c \u4e3a\u4ec0\u4e48\u8981\u5b66\u4e60 \u6e38\u620f\u5f15\u64ce\u662f\u6e38\u620f\u7687\u51a0\u4e0a\u7480\u74a8\u7684\u660e\u73e0\u3002 \u6e38\u620f\u5f15\u64ce\u7684\u5f00\u53d1\u6d89\u53ca\u5230\u4e86\u5404\u884c\u5404\u4e1a\u7684\u77e5\u8bc6\uff0c\u5373\u4f7f\u4f60\u4ee5\u540e\u4e0d\u4ece\u4e8b\u76f8\u5173\u5de5\u4f5c\uff0c\u5b83\u4e5f\u4f9d\u7136\u6709\u5b66\u4e60\u4ef7\u503c\u3002 \u900f\u8fc7\u5b83\uff0c\u4f60\u5c06\u4e86\u89e3\u5230\u4eba\u7c7b\u5982\u4f55\u5c06\u6211\u4eec\u6240\u5904\u7684\u8fd9\u4e2a\u4e16\u754c\u538b\u7f29\u8fdb\u5f15\u64ce\u4e2d\u3002 \u8fd9\u91cc\u6709\u4ec0\u4e48 \u6211\u5c06\u501f\u52a9 GAMES104 \u548c\u4e00\u4e9b\u5176\u4ed6\u8d44\u6599\uff0c\u4e3a\u4f60\u63d0\u4f9b\u8db3\u591f\u4e30\u5bcc\u7684\u7406\u8bba\u77e5\u8bc6\u3002 \u540c\u65f6\u9644\u4e0a\u6211\u5b66\u4e60 Cherno \u7684\u8bfe\u7a0b \u540e\u5f00\u53d1\u7684 VitarEngine \u7684\u4ee3\u7801\uff0c\u4e5f\u8bf7\u4f60\u4eec\u652f\u6301 HazelEngine \u3002","title":"\u5bb6"},{"location":"#_1","text":"\u4f5c\u4e3a\u4e00\u540d\u5927\u4e09\u5b66\u751f\uff0c\u6211\u5c1d\u8bd5\u5199\u4e0b\u8fd9\u4efd\u6587\u6863\uff0c\u4e00\u65b9\u9762\u662f\u7ed9\u6700\u8fd1\u8fd9\u6bb5\u6e38\u620f\u5f15\u64ce\u5b66\u4e60\u7ecf\u5386\u4e00\u4e2a\u603b\u7ed3\uff0c\u540c\u65f6\u8fd9\u4e5f\u5c06\u6210\u4e3a\u6211\u6bd5\u8bbe\u7684\u4e00\u90e8\u5206\uff1b\u53e6\u4e00\u65b9\u9762\u662f\u60f3\u7ed9\u540e\u6765\u8005\u6307\u4e00\u6307\u5927\u6982\u7684\u65b9\u5411\u3002 \u5e0c\u671b\u80fd\u6709\u8d8a\u6765\u8d8a\u591a\u7684\u4eba\u70ed\u7231\u6e38\u620f\u5f15\u64ce\uff0c\u4e86\u89e3\u5b83\uff0c\u7136\u540e\u4f18\u5316\u5b83\uff0c\u4e89\u53d6\u65e9\u65e5\u5b9e\u73b0\u300a\u9ed1\u5ba2\u5e1d\u56fd\u300b\u4e2d\u7684\u573a\u666f\u3002 \u82f1\u6587\u7248 \u7684\u4f1a\u968f\u7740\u8be5\u6587\u6863\u7f13\u6162\u66f4\u65b0\u3002 \u5982\u679c\u4f60\u5728\u9605\u8bfb\u671f\u95f4\u6709\u4efb\u4f55\u95ee\u9898\uff0c\u53ef\u4ee5\u5728\u8be5\u9879\u76ee\u7684 Github \u5730\u5740 \u63d0\u4ea4 issue \u6216\u8005\u5411 2481814748@qq.com \u53d1\u9001\u90ae\u4ef6\uff0c\u6211\u5c06\u4f1a\u975e\u5e38\u611f\u8c22\u60a8\u63d0\u4f9b\u7684\u5b9d\u8d35\u610f\u89c1\u3002","title":"\u5199\u5728\u524d\u9762\u7684\u8bdd"},{"location":"#_2","text":"","title":"\u6b22\u8fce\u6765\u5230\u6e38\u620f\u5f15\u64ce\u7684\u4e16\u754c"},{"location":"#_3","text":"\u6e38\u620f\u5f15\u64ce\u662f\u6e38\u620f\u7687\u51a0\u4e0a\u7480\u74a8\u7684\u660e\u73e0\u3002 \u6e38\u620f\u5f15\u64ce\u7684\u5f00\u53d1\u6d89\u53ca\u5230\u4e86\u5404\u884c\u5404\u4e1a\u7684\u77e5\u8bc6\uff0c\u5373\u4f7f\u4f60\u4ee5\u540e\u4e0d\u4ece\u4e8b\u76f8\u5173\u5de5\u4f5c\uff0c\u5b83\u4e5f\u4f9d\u7136\u6709\u5b66\u4e60\u4ef7\u503c\u3002 \u900f\u8fc7\u5b83\uff0c\u4f60\u5c06\u4e86\u89e3\u5230\u4eba\u7c7b\u5982\u4f55\u5c06\u6211\u4eec\u6240\u5904\u7684\u8fd9\u4e2a\u4e16\u754c\u538b\u7f29\u8fdb\u5f15\u64ce\u4e2d\u3002","title":"\u4e3a\u4ec0\u4e48\u8981\u5b66\u4e60"},{"location":"#_4","text":"\u6211\u5c06\u501f\u52a9 GAMES104 \u548c\u4e00\u4e9b\u5176\u4ed6\u8d44\u6599\uff0c\u4e3a\u4f60\u63d0\u4f9b\u8db3\u591f\u4e30\u5bcc\u7684\u7406\u8bba\u77e5\u8bc6\u3002 \u540c\u65f6\u9644\u4e0a\u6211\u5b66\u4e60 Cherno \u7684\u8bfe\u7a0b \u540e\u5f00\u53d1\u7684 VitarEngine \u7684\u4ee3\u7801\uff0c\u4e5f\u8bf7\u4f60\u4eec\u652f\u6301 HazelEngine \u3002","title":"\u8fd9\u91cc\u6709\u4ec0\u4e48"},{"location":"Introduce/","text":"\u4ec0\u4e48\u662f\u6e38\u620f\u5f15\u64ce \u7ef4\u57fa\u767e\u79d1 \u6e38\u620f\u5f15\u64ce\u662f\u6307\u4e00\u4e9b\u5df2\u7f16\u5199\u597d\u7684\u53ef\u7f16\u8f91\u7535\u8111\u6e38\u620f\u7cfb\u7edf\u6216\u8005\u4e00\u4e9b\u4ea4\u4e92\u5f0f\u5b9e\u65f6\u56fe\u50cf\u5e94\u7528\u7a0b\u5e8f\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002 \u8fd9\u4e9b\u7cfb\u7edf\u4e3a\u6e38\u620f\u8bbe\u8ba1\u8005\u63d0\u4f9b\u7f16\u5199\u6e38\u620f\u6240\u9700\u7684\u5404\u79cd\u5de5\u5177\uff0c\u76ee\u7684\u5728\u4e8e\u8ba9\u6e38\u620f\u8bbe\u8ba1\u8005\u80fd\u591f\u5feb\u901f\u5730\u505a\u51fa\u6e38\u620f\uff0c\u800c\u4e0d\u7528\u4ece\u96f6\u5f00\u59cb\u3002 \u738b\u5e0c\u8001\u5e08 \u9ed1\u5ba2\u5e1d\u56fd\u7684\u6280\u672f\u57fa\u77f3\uff1b \u751f\u4ea7\u521b\u610f\u7684\u5de5\u5177\uff1b \u590d\u6742\u6027\u7cfb\u7edf\u7684\u827a\u672f\u3002 Zong \u4ece\u5ba2\u89c2\u6765\u4e0a\u8bf4\uff0c\u6e38\u620f\u5f15\u64ce\u662f\u4e00\u5806\u6e38\u620f\u5e95\u5c42\u6240\u9700\u7684\u6a21\u5757\u7684\u96c6\u5408\uff0c\u4f46\u662f\u5982\u679c\u4f60\u5c06\u5176\u5f53\u4f5c\u4e00\u4e2a\u590d\u6742\u7684\u673a\u5668\u6216\u8005\u4e16\u754c\uff0c\u90a3\u5b83\u5c31\u662f\u4eba\u7c7b\u827a\u672f\u7684\u96c6\u5927\u6210\u4f5c\u3002 \u5c0a\u91cd\u5b83\uff0c\u6b23\u8d4f\u5b83\uff0c\u7406\u89e3\u5b83\u3002 \u6e38\u620f\u5f15\u64ce\u4f1a\u4e3a\u4f60\u63d0\u4f9b\u4e00\u5957\u5b8c\u6574\u7684\u5f00\u53d1\u5de5\u5177\u94fe\uff0c\u4ee5\u4f9b\u4f60\u5f00\u53d1\u5404\u79cd\u5404\u6837\u7684\u6e38\u620f\uff0c\u751a\u81f3\u662f\u5f71\u89c6\u3002 \u600e\u4e48\u5b66\u4e60\u6e38\u620f\u5f15\u64ce \u6e38\u620f\u5f15\u64ce\u5185\u542b\u4e86\u73b0\u6709\u7684\u5927\u90e8\u5206\u79d1\u5b66\u77e5\u8bc6\uff0c\u90a3\u4e9b\u4e1c\u897f\u9700\u8981\u4f60\u82b1\u51e0\u4e4e\u4e00\u8f88\u5b50\u53bb\u94bb\u7814\u624d\u80fd\u771f\u6b63\u7406\u89e3\u3002 \u6240\u4ee5\u5728\u8fd9\u91cc\uff0c\u6211\u66f4\u591a\u7684\u662f\u4e3a\u4f60\u6784\u5efa\u51fa\u6e38\u620f\u5f15\u64ce\u7684\u7406\u8bba\u6846\u67b6\uff0c\u5269\u4e0b\u7684\u9700\u8981\u4f60\u81ea\u5df1\u4ee5\u540e\u6162\u6162\u586b\u8865\u3002 \u6e38\u620f\u5f15\u64ce\u6846\u67b6 \u4ece\u4e0a\u5f80\u4e0b\u4f9d\u6b21\u662f\u5de5\u5177\u5c42\u3001\u529f\u80fd\u5c42\u3001\u8d44\u6e90\u5c42\u3001\u5e73\u53f0\u5c42\u548c\u6838\u5fc3\u5c42\uff0c\u518d\u52a0\u4e0a\u8d2f\u7a7f\u59cb\u7ec8\u7684\u7b2c\u4e09\u65b9\u5e93\u3002 \u5728\u8fd9\u91cc\u6211\u5c06\u5e73\u53f0\u5c42\u653e\u5728\u6838\u5fc3\u5c42\u4e4b\u4e0a\uff0c\u610f\u5728\u6307\u901a\u8fc7\u62bd\u8c61 API \u5c06\u6838\u5fc3\u5c42\u7684\u4ee3\u7801\u5728\u5e73\u53f0\u5c42\u4e2d\u5b9e\u73b0\uff08 override \uff09\u548c\u5b8c\u5584\u3002 \u5de5\u5177\u5c42 \u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u7f16\u8f91\u5668\u5de5\u5177\uff0c\u6bd4\u5982\u84dd\u56fe\u3002 \u529f\u80fd\u5c42 \u4e3b\u8981\u662f\u901a\u8fc7\u5e95\u5c42\u7684\u6838\u5fc3\u6a21\u5757\u5b9e\u73b0\u5f15\u64ce\u5f00\u53d1\u6240\u9700\u7684\u4e3b\u8981\u529f\u80fd\uff0c\u5e76\u6309\u5e8f Tick \u6bcf\u4e00\u4e2a\u529f\u80fd\u6a21\u5757\u3002 \u591a\u7ebf\u7a0b\u95f4\u7684\u8c03\u5ea6\u4e0e\u7ba1\u7406\u4e5f\u5c5e\u4e8e\u8fd9\u4e00\u5c42\u3002 \u8d44\u6e90\u5c42 \u4e3b\u8981\u662f\u8981\u8bb0\u5f55\u8d44\u6e90\u5185\u90e8\u548c\u8d44\u6e90\u95f4\u7684\u5f15\u7528\u5173\u7cfb\u4ee5\u53ca\u7ba1\u7406\u8d44\u4ea7\u7684\u751f\u547d\u5468\u671f\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c Assimp \u5f15\u5165\u6a21\u578b\u65f6\u4f1a\u6784\u5efa\u7c7b\u4f3c\u4ee5\u4e0b\u7684\u5b58\u50a8\u7ed3\u6784\u3002 \u5e73\u53f0\u5c42 \u4e3b\u8981\u662f\u6839\u636e\u4e0d\u540c\u7684\u6e38\u620f\u5e73\u53f0\u4ee5\u53ca\u6e32\u67d3\u63a5\u53e3\u5f02\u5316\u6838\u5fc3\u5c42\u5f15\u51fa\u7684 API \uff08\u91cd\u8f7d\u865a\u51fd\u6570\u4ee5\u5b9e\u73b0\u591a\u6001\uff09\u3002 \u6838\u5fc3\u5c42 \u5185\u542b\u6570\u5b66\u5e93\uff0c\u4e8b\u4ef6\u76d1\u542c\uff0c\u65e5\u5fd7\u7b49\u7b49\u6838\u5fc3\u529f\u80fd\u3002 \u6570\u636e\u7ed3\u6784\u548c\u5185\u5b58\u7ba1\u7406\u4e5f\u5c5e\u4e8e\u8be5\u5c42\uff0c\u901a\u8fc7\u4f18\u5316\u5e95\u5c42\u7684\u6570\u636e\u5b58\u653e\u4ee5\u51cf\u5c11\u5185\u5b58\u7684\u7a7a\u6d1e\u3002 Vitar Engine \u5728 Vitar Engine \u4e2d\uff0c\u6211\u5e76\u6ca1\u6709\u4e25\u683c\u6309\u7167\u4e0a\u8ff0\u5f15\u64ce\u67b6\u6784\u89c4\u5212\u76ee\u5f55\u7ed3\u6784\u3002 \u4f60\u53ef\u4ee5\u53c2\u8003 Piccolo Engine \u3002 \u4f46\u662f\u5728\u8fd9\u4e2a\u6587\u6863\u4e2d\uff0c\u6211\u5c1d\u8bd5 \u7136\u800c\u5728\u672c\u6587\u6863\u4e2d\uff0c\u6211\u5c06\u5c1d\u8bd5\u6309\u7167\u4e0a\u8ff0\u5f15\u64ce\u67b6\u6784\u5bf9\u6587\u7ae0\u8fdb\u884c\u5206\u7c7b\u3002\u4e0d\u8fc7\u6ca1\u6709\u5de5\u5177\u5c42\uff0c\u56e0\u4e3a\u5b83\u4e3b\u8981\u662f\u91cd\u8f7d\u548c\u7ec4\u88c5\u529f\u80fd\u5c42\uff0c\u5e76\u4e14\u5e73\u53f0\u5c42\u5c06\u4e0e\u6838\u5fc3\u5c42\u5199\u5728\u4e00\u8d77\uff0c\u800c\u4e0d\u662f\u4e3a\u5176\u521b\u5efa\u65b0\u7684\u76ee\u5f55\u3002 \u8d44\u6599\u6765\u6e90 Assimp \u5f15\u5165\u6a21\u578b\u4ecb\u7ecd\u3002","title":"\u4ecb\u7ecd"},{"location":"Introduce/#_1","text":"","title":"\u4ec0\u4e48\u662f\u6e38\u620f\u5f15\u64ce"},{"location":"Introduce/#_2","text":"\u6e38\u620f\u5f15\u64ce\u662f\u6307\u4e00\u4e9b\u5df2\u7f16\u5199\u597d\u7684\u53ef\u7f16\u8f91\u7535\u8111\u6e38\u620f\u7cfb\u7edf\u6216\u8005\u4e00\u4e9b\u4ea4\u4e92\u5f0f\u5b9e\u65f6\u56fe\u50cf\u5e94\u7528\u7a0b\u5e8f\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002 \u8fd9\u4e9b\u7cfb\u7edf\u4e3a\u6e38\u620f\u8bbe\u8ba1\u8005\u63d0\u4f9b\u7f16\u5199\u6e38\u620f\u6240\u9700\u7684\u5404\u79cd\u5de5\u5177\uff0c\u76ee\u7684\u5728\u4e8e\u8ba9\u6e38\u620f\u8bbe\u8ba1\u8005\u80fd\u591f\u5feb\u901f\u5730\u505a\u51fa\u6e38\u620f\uff0c\u800c\u4e0d\u7528\u4ece\u96f6\u5f00\u59cb\u3002","title":"\u7ef4\u57fa\u767e\u79d1"},{"location":"Introduce/#_3","text":"\u9ed1\u5ba2\u5e1d\u56fd\u7684\u6280\u672f\u57fa\u77f3\uff1b \u751f\u4ea7\u521b\u610f\u7684\u5de5\u5177\uff1b \u590d\u6742\u6027\u7cfb\u7edf\u7684\u827a\u672f\u3002","title":"\u738b\u5e0c\u8001\u5e08"},{"location":"Introduce/#zong","text":"\u4ece\u5ba2\u89c2\u6765\u4e0a\u8bf4\uff0c\u6e38\u620f\u5f15\u64ce\u662f\u4e00\u5806\u6e38\u620f\u5e95\u5c42\u6240\u9700\u7684\u6a21\u5757\u7684\u96c6\u5408\uff0c\u4f46\u662f\u5982\u679c\u4f60\u5c06\u5176\u5f53\u4f5c\u4e00\u4e2a\u590d\u6742\u7684\u673a\u5668\u6216\u8005\u4e16\u754c\uff0c\u90a3\u5b83\u5c31\u662f\u4eba\u7c7b\u827a\u672f\u7684\u96c6\u5927\u6210\u4f5c\u3002 \u5c0a\u91cd\u5b83\uff0c\u6b23\u8d4f\u5b83\uff0c\u7406\u89e3\u5b83\u3002 \u6e38\u620f\u5f15\u64ce\u4f1a\u4e3a\u4f60\u63d0\u4f9b\u4e00\u5957\u5b8c\u6574\u7684\u5f00\u53d1\u5de5\u5177\u94fe\uff0c\u4ee5\u4f9b\u4f60\u5f00\u53d1\u5404\u79cd\u5404\u6837\u7684\u6e38\u620f\uff0c\u751a\u81f3\u662f\u5f71\u89c6\u3002","title":"Zong"},{"location":"Introduce/#_4","text":"\u6e38\u620f\u5f15\u64ce\u5185\u542b\u4e86\u73b0\u6709\u7684\u5927\u90e8\u5206\u79d1\u5b66\u77e5\u8bc6\uff0c\u90a3\u4e9b\u4e1c\u897f\u9700\u8981\u4f60\u82b1\u51e0\u4e4e\u4e00\u8f88\u5b50\u53bb\u94bb\u7814\u624d\u80fd\u771f\u6b63\u7406\u89e3\u3002 \u6240\u4ee5\u5728\u8fd9\u91cc\uff0c\u6211\u66f4\u591a\u7684\u662f\u4e3a\u4f60\u6784\u5efa\u51fa\u6e38\u620f\u5f15\u64ce\u7684\u7406\u8bba\u6846\u67b6\uff0c\u5269\u4e0b\u7684\u9700\u8981\u4f60\u81ea\u5df1\u4ee5\u540e\u6162\u6162\u586b\u8865\u3002","title":"\u600e\u4e48\u5b66\u4e60\u6e38\u620f\u5f15\u64ce"},{"location":"Introduce/#_5","text":"\u4ece\u4e0a\u5f80\u4e0b\u4f9d\u6b21\u662f\u5de5\u5177\u5c42\u3001\u529f\u80fd\u5c42\u3001\u8d44\u6e90\u5c42\u3001\u5e73\u53f0\u5c42\u548c\u6838\u5fc3\u5c42\uff0c\u518d\u52a0\u4e0a\u8d2f\u7a7f\u59cb\u7ec8\u7684\u7b2c\u4e09\u65b9\u5e93\u3002 \u5728\u8fd9\u91cc\u6211\u5c06\u5e73\u53f0\u5c42\u653e\u5728\u6838\u5fc3\u5c42\u4e4b\u4e0a\uff0c\u610f\u5728\u6307\u901a\u8fc7\u62bd\u8c61 API \u5c06\u6838\u5fc3\u5c42\u7684\u4ee3\u7801\u5728\u5e73\u53f0\u5c42\u4e2d\u5b9e\u73b0\uff08 override \uff09\u548c\u5b8c\u5584\u3002","title":"\u6e38\u620f\u5f15\u64ce\u6846\u67b6"},{"location":"Introduce/#_6","text":"\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u7f16\u8f91\u5668\u5de5\u5177\uff0c\u6bd4\u5982\u84dd\u56fe\u3002","title":"\u5de5\u5177\u5c42"},{"location":"Introduce/#_7","text":"\u4e3b\u8981\u662f\u901a\u8fc7\u5e95\u5c42\u7684\u6838\u5fc3\u6a21\u5757\u5b9e\u73b0\u5f15\u64ce\u5f00\u53d1\u6240\u9700\u7684\u4e3b\u8981\u529f\u80fd\uff0c\u5e76\u6309\u5e8f Tick \u6bcf\u4e00\u4e2a\u529f\u80fd\u6a21\u5757\u3002 \u591a\u7ebf\u7a0b\u95f4\u7684\u8c03\u5ea6\u4e0e\u7ba1\u7406\u4e5f\u5c5e\u4e8e\u8fd9\u4e00\u5c42\u3002","title":"\u529f\u80fd\u5c42"},{"location":"Introduce/#_8","text":"\u4e3b\u8981\u662f\u8981\u8bb0\u5f55\u8d44\u6e90\u5185\u90e8\u548c\u8d44\u6e90\u95f4\u7684\u5f15\u7528\u5173\u7cfb\u4ee5\u53ca\u7ba1\u7406\u8d44\u4ea7\u7684\u751f\u547d\u5468\u671f\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c Assimp \u5f15\u5165\u6a21\u578b\u65f6\u4f1a\u6784\u5efa\u7c7b\u4f3c\u4ee5\u4e0b\u7684\u5b58\u50a8\u7ed3\u6784\u3002","title":"\u8d44\u6e90\u5c42"},{"location":"Introduce/#_9","text":"\u4e3b\u8981\u662f\u6839\u636e\u4e0d\u540c\u7684\u6e38\u620f\u5e73\u53f0\u4ee5\u53ca\u6e32\u67d3\u63a5\u53e3\u5f02\u5316\u6838\u5fc3\u5c42\u5f15\u51fa\u7684 API \uff08\u91cd\u8f7d\u865a\u51fd\u6570\u4ee5\u5b9e\u73b0\u591a\u6001\uff09\u3002","title":"\u5e73\u53f0\u5c42"},{"location":"Introduce/#_10","text":"\u5185\u542b\u6570\u5b66\u5e93\uff0c\u4e8b\u4ef6\u76d1\u542c\uff0c\u65e5\u5fd7\u7b49\u7b49\u6838\u5fc3\u529f\u80fd\u3002 \u6570\u636e\u7ed3\u6784\u548c\u5185\u5b58\u7ba1\u7406\u4e5f\u5c5e\u4e8e\u8be5\u5c42\uff0c\u901a\u8fc7\u4f18\u5316\u5e95\u5c42\u7684\u6570\u636e\u5b58\u653e\u4ee5\u51cf\u5c11\u5185\u5b58\u7684\u7a7a\u6d1e\u3002","title":"\u6838\u5fc3\u5c42"},{"location":"Introduce/#vitar-engine","text":"\u5728 Vitar Engine \u4e2d\uff0c\u6211\u5e76\u6ca1\u6709\u4e25\u683c\u6309\u7167\u4e0a\u8ff0\u5f15\u64ce\u67b6\u6784\u89c4\u5212\u76ee\u5f55\u7ed3\u6784\u3002 \u4f60\u53ef\u4ee5\u53c2\u8003 Piccolo Engine \u3002 \u4f46\u662f\u5728\u8fd9\u4e2a\u6587\u6863\u4e2d\uff0c\u6211\u5c1d\u8bd5 \u7136\u800c\u5728\u672c\u6587\u6863\u4e2d\uff0c\u6211\u5c06\u5c1d\u8bd5\u6309\u7167\u4e0a\u8ff0\u5f15\u64ce\u67b6\u6784\u5bf9\u6587\u7ae0\u8fdb\u884c\u5206\u7c7b\u3002\u4e0d\u8fc7\u6ca1\u6709\u5de5\u5177\u5c42\uff0c\u56e0\u4e3a\u5b83\u4e3b\u8981\u662f\u91cd\u8f7d\u548c\u7ec4\u88c5\u529f\u80fd\u5c42\uff0c\u5e76\u4e14\u5e73\u53f0\u5c42\u5c06\u4e0e\u6838\u5fc3\u5c42\u5199\u5728\u4e00\u8d77\uff0c\u800c\u4e0d\u662f\u4e3a\u5176\u521b\u5efa\u65b0\u7684\u76ee\u5f55\u3002","title":"Vitar Engine"},{"location":"Introduce/#_11","text":"Assimp \u5f15\u5165\u6a21\u578b\u4ecb\u7ecd\u3002","title":"\u8d44\u6599\u6765\u6e90"},{"location":"Core/EC/","text":"ECS \u4e00\u4e2a\u4f7f\u7528 ECS \u67b6\u6784\u5f00\u53d1\u7684\u6e38\u620f\u57fa\u672c\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 Entity \u4f5c\u4e3a\u4e00\u4e2a\u5b58\u653e Component \u7684\u5bb9\u5668\uff0c\u5bf9\u5916\u63d0\u4f9b ID \u4ee5\u4f9b\u7d22\u5f15\uff1b Component \u7528\u4e8e\u5b58\u653e\u8be5\u7ec4\u4ef6\u7684\u76f8\u5173\u6570\u636e\uff1b System \u5b9e\u73b0 Component \u95f4\u7684\u4ea4\u4e92\u903b\u8f91\u3002 EC \u76f8\u6bd4 ECS \uff0c\u5176\u5c06 System \u4e2d\u7684\u903b\u8f91\u653e\u5165 Component \u4e2d\u5b9e\u73b0\uff0c\u4ece\u800c\u66f4\u597d\u7684\u5bf9\u811a\u672c\u8fdb\u884c\u7ba1\u7406\u3002 Entity class Entity { public: Entity() = default; Entity(entt::entity handle, Scene* scene); Entity(const Entity& other) = default; template<typename T, typename... Args> T& AddComponent(Args&&... args) { HZ_CORE_ASSERT(!HasComponent<T>(), \"Entity already has component!\"); return m_Scene->m_Registry.emplace<T>(m_EntityHandle, std::forward<Args>(args)...); } template<typename T> T& GetComponent() { HZ_CORE_ASSERT(HasComponent<T>(), \"Entity does not have component!\"); return m_Scene->m_Registry.get<T>(m_EntityHandle); } template<typename T> bool HasComponent() { return m_Scene->m_Registry.has<T>(m_EntityHandle); } template<typename T> void RemoveComponent() { HZ_CORE_ASSERT(HasComponent<T>(), \"Entity does not have component!\"); m_Scene->m_Registry.remove<T>(m_EntityHandle); } operator bool() const { return m_EntityHandle != 0; } private: entt::entity m_EntityHandle{ 0 }; Scene* m_Scene = nullptr; }; Component \u57fa\u7840\u7ec4\u4ef6 \u5747\u53ea\u5b58\u50a8\u57fa\u7840\u7684\u5c5e\u6027\u3002 struct TagComponent { std::string Tag; TagComponent() = default; TagComponent(const TagComponent&) = default; TagComponent(const std::string& tag) : Tag(tag) {} }; struct TransformComponent { glm::mat4 Transform{ 1.0f }; TransformComponent() = default; TransformComponent(const TransformComponent&) = default; TransformComponent(const glm::mat4 & transform) : Transform(transform) {} operator glm::mat4& () { return Transform; } operator const glm::mat4& () const { return Transform; } }; struct SpriteRendererComponent { glm::vec4 Color{ 1.0f, 1.0f, 1.0f, 1.0f }; SpriteRendererComponent() = default; SpriteRendererComponent(const SpriteRendererComponent&) = default; SpriteRendererComponent(const glm::vec4& color) : Color(color) {} }; struct CameraComponent { Hazel::Camera Camera; bool Primary = true; // TODO: think about moving to Scene CameraComponent() = default; CameraComponent(const CameraComponent&) = default; CameraComponent(const glm::mat4& projection) : Camera(projection) {} }; \u811a\u672c\u7ec4\u4ef6 \u8be5\u7ec4\u4ef6\u652f\u6301\u586b\u5165 ScriptableEntity \uff0c\u7528 ScriptableEntity \u5b9e\u73b0\u903b\u8f91\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u5728 NativeScriptComponent \u5b9e\u73b0\u662f\u56e0\u4e3a\u5b9e\u73b0\u903b\u8f91\u53ef\u80fd\u9700\u8981\u8c03\u7528\u5176\u4ed6\u7684\u7ec4\u4ef6\uff0c\u800c Component \u662f\u4e0d\u5141\u8bb8\u76f4\u63a5\u8c03\u7528\u5176\u4ed6\u7ec4\u4ef6\u7684\u3002 struct NativeScriptComponent { ScriptableEntity* Instance = nullptr; ScriptableEntity*(*InstantiateScript)(); void (*DestroyScript)(NativeScriptComponent*); template<typename T> void Bind() { InstantiateScript = []() { return static_cast<ScriptableEntity*>(new T()); }; DestroyScript = [](NativeScriptComponent* nsc) { delete nsc->Instance; nsc->Instance = nullptr; }; } class ScriptableEntity { public: virtual ~ScriptableEntity() {} template<typename T> T& GetComponent() { return m_Entity.GetComponent<T>(); } protected: virtual void OnCreate() {} virtual void OnDestroy() {} virtual void OnUpdate(Timestep ts) {} private: Entity m_Entity; friend class Scene; }; \u8d44\u6599\u6765\u6e90 ECS \u3002","title":"EC"},{"location":"Core/EC/#ecs","text":"\u4e00\u4e2a\u4f7f\u7528 ECS \u67b6\u6784\u5f00\u53d1\u7684\u6e38\u620f\u57fa\u672c\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 Entity \u4f5c\u4e3a\u4e00\u4e2a\u5b58\u653e Component \u7684\u5bb9\u5668\uff0c\u5bf9\u5916\u63d0\u4f9b ID \u4ee5\u4f9b\u7d22\u5f15\uff1b Component \u7528\u4e8e\u5b58\u653e\u8be5\u7ec4\u4ef6\u7684\u76f8\u5173\u6570\u636e\uff1b System \u5b9e\u73b0 Component \u95f4\u7684\u4ea4\u4e92\u903b\u8f91\u3002","title":"ECS"},{"location":"Core/EC/#ec","text":"\u76f8\u6bd4 ECS \uff0c\u5176\u5c06 System \u4e2d\u7684\u903b\u8f91\u653e\u5165 Component \u4e2d\u5b9e\u73b0\uff0c\u4ece\u800c\u66f4\u597d\u7684\u5bf9\u811a\u672c\u8fdb\u884c\u7ba1\u7406\u3002","title":"EC"},{"location":"Core/EC/#entity","text":"class Entity { public: Entity() = default; Entity(entt::entity handle, Scene* scene); Entity(const Entity& other) = default; template<typename T, typename... Args> T& AddComponent(Args&&... args) { HZ_CORE_ASSERT(!HasComponent<T>(), \"Entity already has component!\"); return m_Scene->m_Registry.emplace<T>(m_EntityHandle, std::forward<Args>(args)...); } template<typename T> T& GetComponent() { HZ_CORE_ASSERT(HasComponent<T>(), \"Entity does not have component!\"); return m_Scene->m_Registry.get<T>(m_EntityHandle); } template<typename T> bool HasComponent() { return m_Scene->m_Registry.has<T>(m_EntityHandle); } template<typename T> void RemoveComponent() { HZ_CORE_ASSERT(HasComponent<T>(), \"Entity does not have component!\"); m_Scene->m_Registry.remove<T>(m_EntityHandle); } operator bool() const { return m_EntityHandle != 0; } private: entt::entity m_EntityHandle{ 0 }; Scene* m_Scene = nullptr; };","title":"Entity"},{"location":"Core/EC/#component","text":"","title":"Component"},{"location":"Core/EC/#_1","text":"\u5747\u53ea\u5b58\u50a8\u57fa\u7840\u7684\u5c5e\u6027\u3002 struct TagComponent { std::string Tag; TagComponent() = default; TagComponent(const TagComponent&) = default; TagComponent(const std::string& tag) : Tag(tag) {} }; struct TransformComponent { glm::mat4 Transform{ 1.0f }; TransformComponent() = default; TransformComponent(const TransformComponent&) = default; TransformComponent(const glm::mat4 & transform) : Transform(transform) {} operator glm::mat4& () { return Transform; } operator const glm::mat4& () const { return Transform; } }; struct SpriteRendererComponent { glm::vec4 Color{ 1.0f, 1.0f, 1.0f, 1.0f }; SpriteRendererComponent() = default; SpriteRendererComponent(const SpriteRendererComponent&) = default; SpriteRendererComponent(const glm::vec4& color) : Color(color) {} }; struct CameraComponent { Hazel::Camera Camera; bool Primary = true; // TODO: think about moving to Scene CameraComponent() = default; CameraComponent(const CameraComponent&) = default; CameraComponent(const glm::mat4& projection) : Camera(projection) {} };","title":"\u57fa\u7840\u7ec4\u4ef6"},{"location":"Core/EC/#_2","text":"\u8be5\u7ec4\u4ef6\u652f\u6301\u586b\u5165 ScriptableEntity \uff0c\u7528 ScriptableEntity \u5b9e\u73b0\u903b\u8f91\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u5728 NativeScriptComponent \u5b9e\u73b0\u662f\u56e0\u4e3a\u5b9e\u73b0\u903b\u8f91\u53ef\u80fd\u9700\u8981\u8c03\u7528\u5176\u4ed6\u7684\u7ec4\u4ef6\uff0c\u800c Component \u662f\u4e0d\u5141\u8bb8\u76f4\u63a5\u8c03\u7528\u5176\u4ed6\u7ec4\u4ef6\u7684\u3002 struct NativeScriptComponent { ScriptableEntity* Instance = nullptr; ScriptableEntity*(*InstantiateScript)(); void (*DestroyScript)(NativeScriptComponent*); template<typename T> void Bind() { InstantiateScript = []() { return static_cast<ScriptableEntity*>(new T()); }; DestroyScript = [](NativeScriptComponent* nsc) { delete nsc->Instance; nsc->Instance = nullptr; }; } class ScriptableEntity { public: virtual ~ScriptableEntity() {} template<typename T> T& GetComponent() { return m_Entity.GetComponent<T>(); } protected: virtual void OnCreate() {} virtual void OnDestroy() {} virtual void OnUpdate(Timestep ts) {} private: Entity m_Entity; friend class Scene; };","title":"\u811a\u672c\u7ec4\u4ef6"},{"location":"Core/EC/#_3","text":"ECS \u3002","title":"\u8d44\u6599\u6765\u6e90"},{"location":"Core/EventsSystem/","text":"\u7ed3\u6784 \u4f18\u70b9 Application \u50a8\u5b58 Window \u7684\u6307\u9488\uff0c Window \u4e0d\u5fc5\u77e5\u9053 Application \u7684\u5b58\u5728\u3002 \u4e3a Window \u521b\u5efa\u56de\u8c03\u51fd\u6570\uff0c\u8ba9 Window \u81ea\u52a8\u8fd4\u56de\u6d88\u606f\u544a\u77e5 Application \uff0c\u800c\u4e0d\u662f\u901a\u8fc7 Application \u8be2\u95ee Window \u3002 \u5c06 Window \u62bd\u8c61\uff0c\u65b9\u4fbf\u5728\u4e0d\u540c\u7684\u5e73\u53f0\u5b9e\u73b0\u3002 Event EventType \u548c EventCategory \uff1a\u5bf9\u5404\u79cd\u4e8b\u4ef6\u8fdb\u884c\u5206\u7c7b\u3002 enum class EventType { None = 0, WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved, AppTick, AppUpdate, AppRender, KeyPressed, KeyReleased, MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled }; enum EventCategory { None = 0, EventCategoryApplication = BIT(0), EventCategoryInput = BIT(1), EventCategoryKeyboard = BIT(2), EventCategoryMouse = BIT(3), EventCategoryMouseButton = BIT(4) }; Event \uff1a\u4f5c\u4e3a\u57fa\u7c7b\uff0c\u5f15\u5165\u4e8b\u4ef6\u8c03\u5ea6\uff0c\u8bbe\u7f6e\u5e03\u5c14\u53d8\u91cf\u50a8\u5b58\u8be5\u4e8b\u4ef6\u662f\u5426\u5df2\u88ab\u5904\u7406\u3002 class HAZEL_API Event { friend class EventDispatcher; public: virtual EventType GetEventType() const = 0; virtual const char* GetName() const = 0; virtual int GetCategoryFlags() const = 0; virtual std::string ToString() const { return GetName(); } inline bool IsInCategory(EventCategory category) { return GetCategoryFlags() & category; } protected: bool m_Handled = false; }; \u5176\u4e2d\u5c06 m_Handled \u8bbe\u4e3a protected \u578b\uff0c\u662f\u4e3a\u4e86\u4fdd\u8bc1\u5b50\u7c7b\u53ef\u4ee5\u76f4\u63a5\u8bbe\u7f6e\u548c\u8c03\u7528\u8be5\u5c5e\u6027\u3002 \u901a\u8fc7\u5bf9 Event \u7684\u91cd\u8f7d\u548c\u5f02\u5316\uff0c\u5373\u53ef\u5b9e\u73b0\u4e0d\u540c\u7684\u4e8b\u4ef6\u3002 EventDispatcher \uff1a\u7528\u6765\u8bbe\u7f6e\u4e8b\u4ef6\u662f\u5426\u5df2\u88ab\u5904\u7406\u3002 class EventDispatcher { template<typename T> using EventFn = std::function<bool(T&)>; public: EventDispatcher(Event& event) : m_Event(event) { } template<typename T> bool Dispatch(EventFn<T> func) { if (m_Event.GetEventType() == T::GetStaticType()) { m_Event.m_Handled = func(*(T*)&m_Event); return true; } return false; } private: Event& m_Event; }; Window WindowProps \uff1a\u50a8\u5b58 Window \u7684\u57fa\u7840\u5c5e\u6027\u3002 struct WindowProps { std::string Title; unsigned int Width; unsigned int Height; WindowProps(const std::string& title = \"Hazel Engine\", unsigned int width = 1280, unsigned int height = 720) : Title(title), Width(width), Height(height) { } }; Window \uff1a\u4f5c\u4e3a\u57fa\u7c7b\uff0c\u9884\u8bbe\u4e86\u7a97\u53e3\u51fd\u6570\u7684\u6a21\u677f\u4ee5\u53ca\u89c4\u8303\u4e86\u7a97\u53e3\u521b\u5efa\u51fd\u6570\u3002 class HAZEL_API Window { public: using EventCallbackFn = std::function<void(Event&)>; virtual ~Window() {} virtual void OnUpdate() = 0; virtual unsigned int GetWidth() const = 0; virtual unsigned int GetHeight() const = 0; // Window attributes virtual void SetEventCallback(const EventCallbackFn& callback) = 0; virtual void SetVSync(bool enabled) = 0; virtual bool IsVSync() const = 0; static Window* Create(const WindowProps& props = WindowProps()); }; WindowsWindow \uff1a\u91cd\u5199\u5e76\u5b9e\u73b0 Window \u7c7b\uff0c\u589e\u6dfb\u4e86 WindowData \u4ee5\u50a8\u5b58\u4ece\u521b\u5efa\u51fd\u6570\u4f20\u6765\u7684\u6570\u636e\u548c\u5f53\u524d\u7684\u56de\u8c03\u51fd\u6570\u4ee5\u53ca\u5bf9 VSync \u7684\u8bbe\u7f6e\u3002 class WindowsWindow : public Window { public: WindowsWindow(const WindowProps& props); virtual ~WindowsWindow(); void OnUpdate() override; inline unsigned int GetWidth() const override { return m_Data.Width; } inline unsigned int GetHeight() const override { return m_Data.Height; } // Window attributes inline void SetEventCallback(const EventCallbackFn& callback) override { m_Data.EventCallback = callback; } void SetVSync(bool enabled) override; bool IsVSync() const override; private: virtual void Init(const WindowProps& props); virtual void Shutdown(); private: GLFWwindow* m_Window; struct WindowData { std::string Title; unsigned int Width, Height; bool VSync; EventCallbackFn EventCallback; }; WindowData m_Data; }; \u5176\u4e2d GLFW \u4e0b\u7684\u56de\u8c03\u51fd\u6570\u5b9e\u73b0 \u5927\u81f4\u5982\u4e0b\u3002 // Set GLFW callbacks glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); data.Width = width; data.Height = height; WindowResizeEvent event(width, height); data.EventCallback(event); }); glfwSetWindowCloseCallback(m_Window, [](GLFWwindow* window) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); WindowCloseEvent event; data.EventCallback(event); }); glfwSetKeyCallback(m_Window, [](GLFWwindow* window, int key, int scancode, int action, int mods) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); switch (action) { case GLFW_PRESS: { KeyPressedEvent event(key, 0); data.EventCallback(event); break; } case GLFW_RELEASE: { KeyReleasedEvent event(key); data.EventCallback(event); break; } case GLFW_REPEAT: { KeyPressedEvent event(key, 1); data.EventCallback(event); break; } } }); glfwSetMouseButtonCallback(m_Window, [](GLFWwindow* window, int button, int action, int mods) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); switch (action) { case GLFW_PRESS: { MouseButtonPressedEvent event(button); data.EventCallback(event); break; } case GLFW_RELEASE: { MouseButtonReleasedEvent event(button); data.EventCallback(event); break; } } }); glfwSetScrollCallback(m_Window, [](GLFWwindow* window, double xOffset, double yOffset) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); MouseScrolledEvent event((float)xOffset, (float)yOffset); data.EventCallback(event); }); glfwSetCursorPosCallback(m_Window, [](GLFWwindow* window, double xPos, double yPos) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); MouseMovedEvent event((float)xPos, (float)yPos); data.EventCallback(event); }); Application Application \uff1a\u6dfb\u52a0\u4e86\u6307\u5411 Window \u7684\u6307\u9488\u4ee5\u53ca\u5bf9 Event \u7684\u5904\u7406\u51fd\u6570\u3002 class HAZEL_API Application { public: Application(); virtual ~Application(); void Run(); void OnEvent(Event& e); private: bool OnWindowClose(WindowCloseEvent& e); std::unique_ptr<Window> m_Window; bool m_Running = true; }; \u8865\u5145\u77e5\u8bc6 #define \u6e38\u620f\u5f15\u64ce\u4e2d\u4e3a\u4e86\u7b80\u5316\u4ee3\u7801\uff0c\u5e38\u5e38\u4f1a\u521b\u5efa\u8bb8\u591a\u5b8f\u5b9a\u4e49\uff0c\u5982\u3002 #define EVENT_CLASS_TYPE(type) \\ static EventType GetStaticType() { return EventType::##type; }\\ const EventType GetEventType() const override { return GetStaticType(); }\\ const char* GetName() const override { return #type; } \u5176\u4e2d # \u662f\u5c06\u503c\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c ## \u662f\u76f4\u63a5\u8fdb\u884c\u5b57\u7b26\u7684\u62fc\u63a5\u3002 \u4ee5\u4e0b\u4ee3\u7801\u521b\u5efa\u4e86\u4e00\u4e2a Assert \u7c7b\u578b\u7684\u5b8f\u6765\u5224\u65ad\u6570\u636e\u662f\u5426\u4e3a\u7a7a\u3002 #ifdef HZ_ENABLE_ASSERTS #define HAZEL_ASSERT(x, ...) if(!x) {LOG_ERROR(\"Assertion Failed At: {0}\", __VA_ARGS__);\\ __debugbreak();} #define HAZEL_CORE_ASSERT(x, ...) if(!x) {CORE_LOG_ERROR(\"Assertion Failed At: {0}\", __VA_ARGS__);\\ __debugbreak();} #else #define HAZEL_ASSERT(x, ...) // \u975eDebug\u72b6\u6001\u4e0b\u8fd9\u884c\u4ee3\u7801\u6beb\u65e0\u4f5c\u7528 #define HAZEL_CORE_ASSERT(x, ...) #endif \u5176\u4e2d Variadic Arguments \u8868\u793a\u53ef\u53d8\u7684\u53c2\u6570\uff0c __debugbreak \u53ef\u4ee5\u8ba9\u7a0b\u5e8f\u5728\u8fd0\u884c\u5230\u6b64\u5904\u65f6\u81ea\u52a8\u65ad\u70b9\u3002 std::function Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any Callable target \u2013 functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members. The stored callable object is called the target of std::function. If a std::function contains no target, it is called empty. Invoking the target of an empty std::function results in std::bad_function_call exception being thrown. std::function satisfies the requirements of CopyConstructible and CopyAssignable. std::function \u662f\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\u5305\u88c5\u5668\uff0c\u662f\u4e00\u4e2a\u7c7b\u6a21\u677f\uff0c\u53ef\u4ee5\u5bb9\u7eb3\u9664\u4e86\u7c7b\u6210\u5458\u51fd\u6570\u6307\u9488\u4e4b\u5916\u7684\u6240\u6709\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u5b83\u53ef\u4ee5\u7528\u7edf\u4e00\u7684\u65b9\u5f0f\u5904\u7406\u51fd\u6570\u3001\u51fd\u6570\u5bf9\u8c61\u548c\u51fd\u6570\u6307\u9488\uff0c\u5e76\u5141\u8bb8\u4fdd\u5b58\u548c\u5ef6\u8fdf\u5b83\u4eec\u7684\u6267\u884c\u3002 std::function \u53ef\u4ee5\u53d6\u4ee3\u51fd\u6570\u6307\u9488\u7684\u4f5c\u7528\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5ef6\u8fdf\u51fd\u6570\u7684\u6267\u884c\uff0c\u7279\u522b\u9002\u5408\u4f5c\u4e3a\u56de\u8c03\u51fd\u6570\u4f7f\u7528\u3002\u5b83\u6bd4\u666e\u901a\u51fd\u6570\u6307\u9488\u66f4\u52a0\u7684\u7075\u6d3b\u548c\u4fbf\u5229\u3002 \u56e0\u6b64\uff0c std::function \u7684\u4f5c\u7528\u53ef\u4ee5\u5f52\u7ed3\u6210\u3002 std::function \u5bf9 C++ \u4e2d\u5404\u79cd\u53ef\u8c03\u7528\u5b9e\u4f53\uff08\u666e\u901a\u51fd\u6570\u3001 Lambda \u8868\u8fbe\u5f0f\u3001\u51fd\u6570\u6307\u9488\u4ee5\u53ca\u5176\u5b83\u51fd\u6570\u5bf9\u8c61\u7b49\uff09\u7684\u5c01\u88c5\uff0c\u5f62\u6210\u4e00\u4e2a\u65b0\u7684\u53ef\u8c03\u7528\u7684 std::function \u5bf9\u8c61\u4ee5\u7b80\u5316\u8c03\u7528\uff1b std::function \u5bf9\u8c61\u662f\u5bf9 C++ \u4e2d\u73b0\u6709\u7684\u53ef\u8c03\u7528\u5b9e\u4f53\u7684\u4e00\u79cd\u7c7b\u578b\u5b89\u5168\u7684\u5305\u88f9\uff08\u5982\u51fd\u6570\u6307\u9488\u8fd9\u7c7b\u53ef\u8c03\u7528\u5b9e\u4f53\u662f\u7c7b\u578b\u4e0d\u5b89\u5168\u7684\uff09\u3002 \u8c03\u7528\u65f6\u53ea\u9700\u5c06\u51fd\u6570\u8f6c\u6362\u6210\u7279\u5b9a\u7684\u51fd\u6570\u578b\u5373\u53ef\u4f7f\u7528\u3002 std::function <void()> a = static_cast<fun_ptr_a>(print); std::function <void(int)> b = static_cast<fun_ptr_b>(print); std::bind \u6982\u8ff0 std::bind \u53ef\u4ee5\u770b\u4f5c\u4e00\u4e2a\u901a\u7528\u7684\u51fd\u6570\u9002\u914d\u5668\uff0c\u6240\u8c13\u9002\u914d\u5668\uff0c\u5373\u4f7f\u67d0\u79cd\u4e8b\u7269\u7684\u884c\u4e3a\u7c7b\u4f3c\u4e8e\u53e6\u5916\u4e00\u79cd\u4e8b\u7269\u7684\u4e00\u79cd\u673a\u5236\uff0c\u5982\u5bb9\u5668\u9002\u914d\u5668\uff1a stack \uff08\u6808\uff09\u3001 queue \uff08\u961f\u5217\uff09\u3001 priority_queue \uff08\u4f18\u5148\u7ea7\u961f\u5217\uff09\u3002 bind \u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u751f\u6210\u4e00\u4e2a\u65b0\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u6765\u9002\u914d\u539f\u5bf9\u8c61\u3002 \u51fd\u6570\u539f\u578b template <class Fn, class... Args> /* unspecified */ bind (Fn&& fn, Args&&... args); bind \u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u9017\u53f7\u5206\u5272\u7684\u53c2\u6570\u5217\u8868 args \uff0c\u5bf9\u5e94\u7ed9\u5b9a\u51fd\u6570\u5bf9\u8c61 fn \u7684\u53c2\u6570\uff0c\u8fd4\u56de\u4e00\u4e2a\u65b0\u7684\u51fd\u6570\u5bf9\u8c61\u3002 \u53c2\u6570\u5217\u8868 args \u4e2d\u3002 \u5982\u679c\u7ed1\u5b9a\u5230\u4e00\u4e2a\u503c\uff0c\u5219\u8c03\u7528\u8fd4\u56de\u7684\u51fd\u6570\u5bf9\u8c61\u5c06\u59cb\u7ec8\u4f7f\u7528\u8be5\u503c\u4f5c\u4e3a\u53c2\u6570\uff1b \u5982\u679c\u662f\u4e00\u4e2a\u5f62\u5982 _n \u7684\u5360\u4f4d\u7b26\uff0c\u5219\u8c03\u7528\u8fd4\u56de\u7684\u51fd\u6570\u5bf9\u8c61\u4f1a\u8f6c\u53d1\u4f20\u9012\u7ed9\u8c03\u7528\u7684\u53c2\u6570\uff08\u8be5\u53c2\u6570\u7684\u987a\u5e8f\u53f7\u7531\u5360\u4f4d\u7b26\u6307\u5b9a\uff09\u3002 \u4f7f\u7528 std::bind \u4e00\u822c\u4e0e std::function \u4e00\u8d77\u4f7f\u7528\uff0c std::bind \u7684\u8fd4\u56de\u503c\u53ef\u4ee5\u76f4\u63a5\u7528 std::function \u50a8\u5b58\u3002 CallBack \u5b9e\u73b0 \u5b9a\u4e49\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff1b \u63d0\u4f9b\u51fd\u6570\u5b9e\u73b0\u7684\u4e00\u65b9\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u5c06\u56de\u8c03\u51fd\u6570\u7684\u51fd\u6570\u6307\u9488\u6ce8\u518c\u7ed9\u8c03\u7528\u8005\uff1b \u5f53\u7279\u5b9a\u7684\u4e8b\u4ef6\u6216\u6761\u4ef6\u53d1\u751f\u7684\u65f6\u5019\uff0c\u8c03\u7528\u8005\u4f7f\u7528\u51fd\u6570\u6307\u9488\u8c03\u7528\u56de\u8c03\u51fd\u6570\u5bf9\u4e8b\u4ef6\u8fdb\u884c\u5904\u7406\u3002 \u4f18\u70b9 \u56e0\u4e3a\u4f7f\u7528\u6b64\u51fd\u6570\u53ef\u4ee5\u628a\u8c03\u7528\u8005\u4e0e\u88ab\u8c03\u7528\u8005\u5206\u5f00\uff0c\u6240\u4ee5\u8c03\u7528\u8005\u4e0d\u5173\u5fc3\u8c01\u662f\u88ab\u8c03\u7528\u8005\u3002\u5b83\u53ea\u9700\u77e5\u9053\u5b58\u5728\u4e00\u4e2a\u5177\u6709\u7279\u5b9a\u539f\u578b\u548c\u9650\u5236\u6761\u4ef6\u7684\u88ab\u8c03\u7528\u51fd\u6570\u3002 \u7b80\u800c\u8a00\u4e4b\uff0c\u56de\u8c03\u51fd\u6570\u5c31\u662f\u5141\u8bb8\u7528\u6237\u628a\u9700\u8981\u8c03\u7528\u7684\u51fd\u6570\u7684\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9\u4e00\u4e2a\u51fd\u6570\uff0c\u4ee5\u4fbf\u8be5\u51fd\u6570\u5728\u5904\u7406\u76f8\u4f3c\u4e8b\u4ef6\u7684\u65f6\u5019\u53ef\u4ee5\u7075\u6d3b\u7684\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u6cd5\u3002 virtual \u5728\u6ca1\u6709 virtual \u7684\u60c5\u51b5\u4e0b\uff0c\u4ee5\u57fa\u7c7b\u6307\u9488\u8c03\u7528\u65f6\u7f16\u8bd1\u5668\u5e76\u4e0d\u77e5\u9053\u6bd4\u57fa\u7c7b\u66f4\u591a\u7684\u4e1c\u897f\uff0c\u901a\u5e38\u8c03\u7528\u51fd\u6570\u7684\u57fa\u7c7b\u7248\u672c\uff1b \u5f53\u7528 virtual \u58f0\u660e\u51fd\u6570\u65f6\uff0c\u6bcf\u5f53\u521b\u5efa\u4e00\u4e2a\u5305\u542b\u865a\u51fd\u6570\u7684\u7c7b\u6216\u8005\u4ece\u5305\u542b\u865a\u51fd\u6570\u7684\u7c7b\u6d3e\u751f\u7684\u7c7b\u65f6\uff0c\u7f16\u8bd1\u5668\u5c31\u521b\u5efa\u4e00\u4e2a VTABLE \uff1b \u5982\u679c\u6d3e\u751f\u7c7b\u6ca1\u6709\u5bf9\u57fa\u7c7b\u7684 virtual \u51fd\u6570\u8fdb\u884c\u91cd\u65b0\u5b9a\u4e49\uff0c VTABLE \u4e2d\u5c31\u586b\u5145\u57fa\u7c7b\u7684\u865a\u51fd\u6570\u7684\u5730\u5740\uff1b \u7f16\u8bd1\u5668\u4f1a\u5728\u7c7b\u4e2d\u653e\u7f6e\u4e00\u4e2a VPTR \uff0c VPTR \u6307\u5411\u76f8\u5e94\u7684 VTABLE \uff0c VPTR \u7684\u521d\u59cb\u5316\u5728\u6784\u9020\u51fd\u6570\u4e2d\u5b8c\u6210\u3002 \u6211\u7684\u7406\u89e3\u662f\uff0c\u7236\u7c7b\u7684\u6240\u6709\u865a\u51fd\u6570\u4f1a\u88ab\u6c47\u603b\u6210\u4e00\u5f20\u8868\uff0c\u5b50\u7c7b\u7ee7\u627f\u65f6\u4f1a\u5f00\u8f9f\u4e00\u5757\u5185\u5b58\u653e\u7f6e\u8be5\u8868\u548c\u4e00\u4e2a\u6307\u5411\u8be5\u8868\u7684\u6307\u9488\uff0c\u5982\u679c\u91cd\u8f7d\u4e86\u5c31\u8986\u76d6\u8868\u4e2d\u76f8\u5e94\u7684\u51fd\u6570\u3002 \u503c\u5f97\u6ce8\u610f\u7684\u662f\u4e4b\u6240\u4ee5\u89c4\u5b9a\u7236\u7c7b\u7684\u6790\u6784\u51fd\u6570\u5fc5\u987b\u4e3a\u865a\u51fd\u6570\uff0c\u662f\u4e3a\u4e86\u9632\u6b62 delete \u5b50\u7c7b\u65f6\u6ca1\u6709 delete \u7236\u7c7b\uff0c\u4ece\u800c\u9020\u6210\u5185\u5b58\u6ea2\u51fa\u3002 std::unique_ptr \u548c std::shared_ptr std::unique_ptr std::unique_ptr \u53ea\u5141\u8bb8\u4e00\u4e2a\u6307\u9488\u6307\u5411\u540c\u4e00\u4e2a\u5bf9\u8c61\uff0c\u6240\u4ee5\u6307\u9488\u88ab\u9500\u6bc1\u65f6\u4f1a\u81ea\u52a8\u9500\u6bc1\u5bf9\u8c61\uff0c\u53ef\u4ee5\u901a\u8fc7 std::move \u66f4\u6539\u6240\u6709\u6743\u3002 \u63a8\u8350\u4f7f\u7528 make_unique \u521b\u5efa\u4ee5\u51cf\u5c11\u4ee3\u7801\u91cd\u590d\u3002 std::shared_ptr std::shared_ptr \u5141\u8bb8\u591a\u4e2a\u6307\u9488\u6307\u5411\u540c\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5185\u90e8\u6709\u8ba1\u6570\u5668\u8bb0\u5f55\u6307\u9488\u6570\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7 std::move \u66f4\u6539\u6240\u6709\u6743\u3002 \u63a8\u8350\u4f7f\u7528 make_shared \u521b\u5efa\u4ee5\u51cf\u5c11\u4ee3\u7801\u91cd\u590d\u3002 VSync \u5782\u76f4\u540c\u6b65\u65e8\u5728\u89e3\u51b3\u753b\u9762\u7684 FPS \u4e0e\u663e\u793a\u5668\u7684\u5e27\u7387\u4e0d\u540c\u6b65\u7684\u95ee\u9898\uff0c\u5f53\u4e8c\u8005\u5b58\u5728\u5dee\u8ddd\u65f6\uff0c\u53ef\u80fd\u4f1a\u51fa\u73b0 Screen Tearing \uff08\u5c4f\u5e55\u6495\u626f\uff09\u7684\u60c5\u51b5\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4e0b\u9762\u7684\u56fe\u793a\u5c55\u793a\u4e86 GPU \u548c\u663e\u793a\u5668\u7ed8\u5236\u5e27\u7387\u4e0d\u540c\u6b65\u5bfc\u81f4\u5c4f\u5e55\u6495\u626f\u7684\u60c5\u51b5\u3002 \u597d\u5904 \u964d\u4f4e GPU \u7684\u5e27\u7387\uff0c\u4f7f\u5176\u8ddf\u663e\u793a\u5668\u7684\u5e27\u7387\u4e00\u6837 \u5bf9\u4e8e\u4e00\u4e9b\u8001\u6e38\u620f\uff0c GPU \u5e27\u7387\u4f1a\u7279\u522b\u9ad8\uff0c\u8fd9\u5f88\u6d88\u8017\u6027\u80fd\uff0c\u800c\u5f00\u542f\u5782\u76f4\u540c\u6b65\u80fd\u540c\u6b65 GPU \u5e27\u7387\u5230\u663e\u793a\u5668\u7684\u5e27\u7387\uff0c\u4ece\u800c\u51cf\u5c11 GPU \u7684\u8ba1\u7b97\u91cf\u3002 \u574f\u5904 \u53ef\u80fd\u4f1a\u611f\u53d7\u5230 Input \u8f93\u5165\uff0c\u6bd4\u5982\u9f20\u6807\u548c\u952e\u76d8\u8f93\u5165\u7684\u5ef6\u8fdf\uff08\u4fd7\u79f0\u4e0d\u8ddf\u624b\uff09\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u7684\u533a\u95f4\u8f93\u5165\u952e\u76d8\u4f1a\u5ef6\u8fdf\u5230\u4e0b\u4e00\u5e27\u3002 \u8d44\u6599\u6765\u6e90 #define \u3002 std::function \u3002 std::bind \u3002 CallBack \u3002 virtual \u3002 std::make_unique unique_ptr make_shared \u3002 VSync \u3002","title":"\u4e8b\u4ef6\u7cfb\u7edf"},{"location":"Core/EventsSystem/#_1","text":"","title":"\u7ed3\u6784"},{"location":"Core/EventsSystem/#_2","text":"Application \u50a8\u5b58 Window \u7684\u6307\u9488\uff0c Window \u4e0d\u5fc5\u77e5\u9053 Application \u7684\u5b58\u5728\u3002 \u4e3a Window \u521b\u5efa\u56de\u8c03\u51fd\u6570\uff0c\u8ba9 Window \u81ea\u52a8\u8fd4\u56de\u6d88\u606f\u544a\u77e5 Application \uff0c\u800c\u4e0d\u662f\u901a\u8fc7 Application \u8be2\u95ee Window \u3002 \u5c06 Window \u62bd\u8c61\uff0c\u65b9\u4fbf\u5728\u4e0d\u540c\u7684\u5e73\u53f0\u5b9e\u73b0\u3002","title":"\u4f18\u70b9"},{"location":"Core/EventsSystem/#event","text":"EventType \u548c EventCategory \uff1a\u5bf9\u5404\u79cd\u4e8b\u4ef6\u8fdb\u884c\u5206\u7c7b\u3002 enum class EventType { None = 0, WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved, AppTick, AppUpdate, AppRender, KeyPressed, KeyReleased, MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled }; enum EventCategory { None = 0, EventCategoryApplication = BIT(0), EventCategoryInput = BIT(1), EventCategoryKeyboard = BIT(2), EventCategoryMouse = BIT(3), EventCategoryMouseButton = BIT(4) }; Event \uff1a\u4f5c\u4e3a\u57fa\u7c7b\uff0c\u5f15\u5165\u4e8b\u4ef6\u8c03\u5ea6\uff0c\u8bbe\u7f6e\u5e03\u5c14\u53d8\u91cf\u50a8\u5b58\u8be5\u4e8b\u4ef6\u662f\u5426\u5df2\u88ab\u5904\u7406\u3002 class HAZEL_API Event { friend class EventDispatcher; public: virtual EventType GetEventType() const = 0; virtual const char* GetName() const = 0; virtual int GetCategoryFlags() const = 0; virtual std::string ToString() const { return GetName(); } inline bool IsInCategory(EventCategory category) { return GetCategoryFlags() & category; } protected: bool m_Handled = false; }; \u5176\u4e2d\u5c06 m_Handled \u8bbe\u4e3a protected \u578b\uff0c\u662f\u4e3a\u4e86\u4fdd\u8bc1\u5b50\u7c7b\u53ef\u4ee5\u76f4\u63a5\u8bbe\u7f6e\u548c\u8c03\u7528\u8be5\u5c5e\u6027\u3002 \u901a\u8fc7\u5bf9 Event \u7684\u91cd\u8f7d\u548c\u5f02\u5316\uff0c\u5373\u53ef\u5b9e\u73b0\u4e0d\u540c\u7684\u4e8b\u4ef6\u3002 EventDispatcher \uff1a\u7528\u6765\u8bbe\u7f6e\u4e8b\u4ef6\u662f\u5426\u5df2\u88ab\u5904\u7406\u3002 class EventDispatcher { template<typename T> using EventFn = std::function<bool(T&)>; public: EventDispatcher(Event& event) : m_Event(event) { } template<typename T> bool Dispatch(EventFn<T> func) { if (m_Event.GetEventType() == T::GetStaticType()) { m_Event.m_Handled = func(*(T*)&m_Event); return true; } return false; } private: Event& m_Event; };","title":"Event"},{"location":"Core/EventsSystem/#window","text":"WindowProps \uff1a\u50a8\u5b58 Window \u7684\u57fa\u7840\u5c5e\u6027\u3002 struct WindowProps { std::string Title; unsigned int Width; unsigned int Height; WindowProps(const std::string& title = \"Hazel Engine\", unsigned int width = 1280, unsigned int height = 720) : Title(title), Width(width), Height(height) { } }; Window \uff1a\u4f5c\u4e3a\u57fa\u7c7b\uff0c\u9884\u8bbe\u4e86\u7a97\u53e3\u51fd\u6570\u7684\u6a21\u677f\u4ee5\u53ca\u89c4\u8303\u4e86\u7a97\u53e3\u521b\u5efa\u51fd\u6570\u3002 class HAZEL_API Window { public: using EventCallbackFn = std::function<void(Event&)>; virtual ~Window() {} virtual void OnUpdate() = 0; virtual unsigned int GetWidth() const = 0; virtual unsigned int GetHeight() const = 0; // Window attributes virtual void SetEventCallback(const EventCallbackFn& callback) = 0; virtual void SetVSync(bool enabled) = 0; virtual bool IsVSync() const = 0; static Window* Create(const WindowProps& props = WindowProps()); }; WindowsWindow \uff1a\u91cd\u5199\u5e76\u5b9e\u73b0 Window \u7c7b\uff0c\u589e\u6dfb\u4e86 WindowData \u4ee5\u50a8\u5b58\u4ece\u521b\u5efa\u51fd\u6570\u4f20\u6765\u7684\u6570\u636e\u548c\u5f53\u524d\u7684\u56de\u8c03\u51fd\u6570\u4ee5\u53ca\u5bf9 VSync \u7684\u8bbe\u7f6e\u3002 class WindowsWindow : public Window { public: WindowsWindow(const WindowProps& props); virtual ~WindowsWindow(); void OnUpdate() override; inline unsigned int GetWidth() const override { return m_Data.Width; } inline unsigned int GetHeight() const override { return m_Data.Height; } // Window attributes inline void SetEventCallback(const EventCallbackFn& callback) override { m_Data.EventCallback = callback; } void SetVSync(bool enabled) override; bool IsVSync() const override; private: virtual void Init(const WindowProps& props); virtual void Shutdown(); private: GLFWwindow* m_Window; struct WindowData { std::string Title; unsigned int Width, Height; bool VSync; EventCallbackFn EventCallback; }; WindowData m_Data; }; \u5176\u4e2d GLFW \u4e0b\u7684\u56de\u8c03\u51fd\u6570\u5b9e\u73b0 \u5927\u81f4\u5982\u4e0b\u3002 // Set GLFW callbacks glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); data.Width = width; data.Height = height; WindowResizeEvent event(width, height); data.EventCallback(event); }); glfwSetWindowCloseCallback(m_Window, [](GLFWwindow* window) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); WindowCloseEvent event; data.EventCallback(event); }); glfwSetKeyCallback(m_Window, [](GLFWwindow* window, int key, int scancode, int action, int mods) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); switch (action) { case GLFW_PRESS: { KeyPressedEvent event(key, 0); data.EventCallback(event); break; } case GLFW_RELEASE: { KeyReleasedEvent event(key); data.EventCallback(event); break; } case GLFW_REPEAT: { KeyPressedEvent event(key, 1); data.EventCallback(event); break; } } }); glfwSetMouseButtonCallback(m_Window, [](GLFWwindow* window, int button, int action, int mods) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); switch (action) { case GLFW_PRESS: { MouseButtonPressedEvent event(button); data.EventCallback(event); break; } case GLFW_RELEASE: { MouseButtonReleasedEvent event(button); data.EventCallback(event); break; } } }); glfwSetScrollCallback(m_Window, [](GLFWwindow* window, double xOffset, double yOffset) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); MouseScrolledEvent event((float)xOffset, (float)yOffset); data.EventCallback(event); }); glfwSetCursorPosCallback(m_Window, [](GLFWwindow* window, double xPos, double yPos) { WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window); MouseMovedEvent event((float)xPos, (float)yPos); data.EventCallback(event); });","title":"Window"},{"location":"Core/EventsSystem/#application","text":"Application \uff1a\u6dfb\u52a0\u4e86\u6307\u5411 Window \u7684\u6307\u9488\u4ee5\u53ca\u5bf9 Event \u7684\u5904\u7406\u51fd\u6570\u3002 class HAZEL_API Application { public: Application(); virtual ~Application(); void Run(); void OnEvent(Event& e); private: bool OnWindowClose(WindowCloseEvent& e); std::unique_ptr<Window> m_Window; bool m_Running = true; };","title":"Application"},{"location":"Core/EventsSystem/#_3","text":"","title":"\u8865\u5145\u77e5\u8bc6"},{"location":"Core/EventsSystem/#define","text":"\u6e38\u620f\u5f15\u64ce\u4e2d\u4e3a\u4e86\u7b80\u5316\u4ee3\u7801\uff0c\u5e38\u5e38\u4f1a\u521b\u5efa\u8bb8\u591a\u5b8f\u5b9a\u4e49\uff0c\u5982\u3002 #define EVENT_CLASS_TYPE(type) \\ static EventType GetStaticType() { return EventType::##type; }\\ const EventType GetEventType() const override { return GetStaticType(); }\\ const char* GetName() const override { return #type; } \u5176\u4e2d # \u662f\u5c06\u503c\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c ## \u662f\u76f4\u63a5\u8fdb\u884c\u5b57\u7b26\u7684\u62fc\u63a5\u3002 \u4ee5\u4e0b\u4ee3\u7801\u521b\u5efa\u4e86\u4e00\u4e2a Assert \u7c7b\u578b\u7684\u5b8f\u6765\u5224\u65ad\u6570\u636e\u662f\u5426\u4e3a\u7a7a\u3002 #ifdef HZ_ENABLE_ASSERTS #define HAZEL_ASSERT(x, ...) if(!x) {LOG_ERROR(\"Assertion Failed At: {0}\", __VA_ARGS__);\\ __debugbreak();} #define HAZEL_CORE_ASSERT(x, ...) if(!x) {CORE_LOG_ERROR(\"Assertion Failed At: {0}\", __VA_ARGS__);\\ __debugbreak();} #else #define HAZEL_ASSERT(x, ...) // \u975eDebug\u72b6\u6001\u4e0b\u8fd9\u884c\u4ee3\u7801\u6beb\u65e0\u4f5c\u7528 #define HAZEL_CORE_ASSERT(x, ...) #endif \u5176\u4e2d Variadic Arguments \u8868\u793a\u53ef\u53d8\u7684\u53c2\u6570\uff0c __debugbreak \u53ef\u4ee5\u8ba9\u7a0b\u5e8f\u5728\u8fd0\u884c\u5230\u6b64\u5904\u65f6\u81ea\u52a8\u65ad\u70b9\u3002","title":"#define"},{"location":"Core/EventsSystem/#stdfunction","text":"Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any Callable target \u2013 functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members. The stored callable object is called the target of std::function. If a std::function contains no target, it is called empty. Invoking the target of an empty std::function results in std::bad_function_call exception being thrown. std::function satisfies the requirements of CopyConstructible and CopyAssignable. std::function \u662f\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\u5305\u88c5\u5668\uff0c\u662f\u4e00\u4e2a\u7c7b\u6a21\u677f\uff0c\u53ef\u4ee5\u5bb9\u7eb3\u9664\u4e86\u7c7b\u6210\u5458\u51fd\u6570\u6307\u9488\u4e4b\u5916\u7684\u6240\u6709\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u5b83\u53ef\u4ee5\u7528\u7edf\u4e00\u7684\u65b9\u5f0f\u5904\u7406\u51fd\u6570\u3001\u51fd\u6570\u5bf9\u8c61\u548c\u51fd\u6570\u6307\u9488\uff0c\u5e76\u5141\u8bb8\u4fdd\u5b58\u548c\u5ef6\u8fdf\u5b83\u4eec\u7684\u6267\u884c\u3002 std::function \u53ef\u4ee5\u53d6\u4ee3\u51fd\u6570\u6307\u9488\u7684\u4f5c\u7528\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5ef6\u8fdf\u51fd\u6570\u7684\u6267\u884c\uff0c\u7279\u522b\u9002\u5408\u4f5c\u4e3a\u56de\u8c03\u51fd\u6570\u4f7f\u7528\u3002\u5b83\u6bd4\u666e\u901a\u51fd\u6570\u6307\u9488\u66f4\u52a0\u7684\u7075\u6d3b\u548c\u4fbf\u5229\u3002 \u56e0\u6b64\uff0c std::function \u7684\u4f5c\u7528\u53ef\u4ee5\u5f52\u7ed3\u6210\u3002 std::function \u5bf9 C++ \u4e2d\u5404\u79cd\u53ef\u8c03\u7528\u5b9e\u4f53\uff08\u666e\u901a\u51fd\u6570\u3001 Lambda \u8868\u8fbe\u5f0f\u3001\u51fd\u6570\u6307\u9488\u4ee5\u53ca\u5176\u5b83\u51fd\u6570\u5bf9\u8c61\u7b49\uff09\u7684\u5c01\u88c5\uff0c\u5f62\u6210\u4e00\u4e2a\u65b0\u7684\u53ef\u8c03\u7528\u7684 std::function \u5bf9\u8c61\u4ee5\u7b80\u5316\u8c03\u7528\uff1b std::function \u5bf9\u8c61\u662f\u5bf9 C++ \u4e2d\u73b0\u6709\u7684\u53ef\u8c03\u7528\u5b9e\u4f53\u7684\u4e00\u79cd\u7c7b\u578b\u5b89\u5168\u7684\u5305\u88f9\uff08\u5982\u51fd\u6570\u6307\u9488\u8fd9\u7c7b\u53ef\u8c03\u7528\u5b9e\u4f53\u662f\u7c7b\u578b\u4e0d\u5b89\u5168\u7684\uff09\u3002 \u8c03\u7528\u65f6\u53ea\u9700\u5c06\u51fd\u6570\u8f6c\u6362\u6210\u7279\u5b9a\u7684\u51fd\u6570\u578b\u5373\u53ef\u4f7f\u7528\u3002 std::function <void()> a = static_cast<fun_ptr_a>(print); std::function <void(int)> b = static_cast<fun_ptr_b>(print);","title":"std::function"},{"location":"Core/EventsSystem/#stdbind","text":"","title":"std::bind"},{"location":"Core/EventsSystem/#_4","text":"std::bind \u53ef\u4ee5\u770b\u4f5c\u4e00\u4e2a\u901a\u7528\u7684\u51fd\u6570\u9002\u914d\u5668\uff0c\u6240\u8c13\u9002\u914d\u5668\uff0c\u5373\u4f7f\u67d0\u79cd\u4e8b\u7269\u7684\u884c\u4e3a\u7c7b\u4f3c\u4e8e\u53e6\u5916\u4e00\u79cd\u4e8b\u7269\u7684\u4e00\u79cd\u673a\u5236\uff0c\u5982\u5bb9\u5668\u9002\u914d\u5668\uff1a stack \uff08\u6808\uff09\u3001 queue \uff08\u961f\u5217\uff09\u3001 priority_queue \uff08\u4f18\u5148\u7ea7\u961f\u5217\uff09\u3002 bind \u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u751f\u6210\u4e00\u4e2a\u65b0\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u6765\u9002\u914d\u539f\u5bf9\u8c61\u3002","title":"\u6982\u8ff0"},{"location":"Core/EventsSystem/#_5","text":"template <class Fn, class... Args> /* unspecified */ bind (Fn&& fn, Args&&... args); bind \u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u9017\u53f7\u5206\u5272\u7684\u53c2\u6570\u5217\u8868 args \uff0c\u5bf9\u5e94\u7ed9\u5b9a\u51fd\u6570\u5bf9\u8c61 fn \u7684\u53c2\u6570\uff0c\u8fd4\u56de\u4e00\u4e2a\u65b0\u7684\u51fd\u6570\u5bf9\u8c61\u3002 \u53c2\u6570\u5217\u8868 args \u4e2d\u3002 \u5982\u679c\u7ed1\u5b9a\u5230\u4e00\u4e2a\u503c\uff0c\u5219\u8c03\u7528\u8fd4\u56de\u7684\u51fd\u6570\u5bf9\u8c61\u5c06\u59cb\u7ec8\u4f7f\u7528\u8be5\u503c\u4f5c\u4e3a\u53c2\u6570\uff1b \u5982\u679c\u662f\u4e00\u4e2a\u5f62\u5982 _n \u7684\u5360\u4f4d\u7b26\uff0c\u5219\u8c03\u7528\u8fd4\u56de\u7684\u51fd\u6570\u5bf9\u8c61\u4f1a\u8f6c\u53d1\u4f20\u9012\u7ed9\u8c03\u7528\u7684\u53c2\u6570\uff08\u8be5\u53c2\u6570\u7684\u987a\u5e8f\u53f7\u7531\u5360\u4f4d\u7b26\u6307\u5b9a\uff09\u3002","title":"\u51fd\u6570\u539f\u578b"},{"location":"Core/EventsSystem/#_6","text":"std::bind \u4e00\u822c\u4e0e std::function \u4e00\u8d77\u4f7f\u7528\uff0c std::bind \u7684\u8fd4\u56de\u503c\u53ef\u4ee5\u76f4\u63a5\u7528 std::function \u50a8\u5b58\u3002","title":"\u4f7f\u7528"},{"location":"Core/EventsSystem/#callback","text":"","title":"CallBack"},{"location":"Core/EventsSystem/#_7","text":"\u5b9a\u4e49\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff1b \u63d0\u4f9b\u51fd\u6570\u5b9e\u73b0\u7684\u4e00\u65b9\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u5c06\u56de\u8c03\u51fd\u6570\u7684\u51fd\u6570\u6307\u9488\u6ce8\u518c\u7ed9\u8c03\u7528\u8005\uff1b \u5f53\u7279\u5b9a\u7684\u4e8b\u4ef6\u6216\u6761\u4ef6\u53d1\u751f\u7684\u65f6\u5019\uff0c\u8c03\u7528\u8005\u4f7f\u7528\u51fd\u6570\u6307\u9488\u8c03\u7528\u56de\u8c03\u51fd\u6570\u5bf9\u4e8b\u4ef6\u8fdb\u884c\u5904\u7406\u3002","title":"\u5b9e\u73b0"},{"location":"Core/EventsSystem/#_8","text":"\u56e0\u4e3a\u4f7f\u7528\u6b64\u51fd\u6570\u53ef\u4ee5\u628a\u8c03\u7528\u8005\u4e0e\u88ab\u8c03\u7528\u8005\u5206\u5f00\uff0c\u6240\u4ee5\u8c03\u7528\u8005\u4e0d\u5173\u5fc3\u8c01\u662f\u88ab\u8c03\u7528\u8005\u3002\u5b83\u53ea\u9700\u77e5\u9053\u5b58\u5728\u4e00\u4e2a\u5177\u6709\u7279\u5b9a\u539f\u578b\u548c\u9650\u5236\u6761\u4ef6\u7684\u88ab\u8c03\u7528\u51fd\u6570\u3002 \u7b80\u800c\u8a00\u4e4b\uff0c\u56de\u8c03\u51fd\u6570\u5c31\u662f\u5141\u8bb8\u7528\u6237\u628a\u9700\u8981\u8c03\u7528\u7684\u51fd\u6570\u7684\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9\u4e00\u4e2a\u51fd\u6570\uff0c\u4ee5\u4fbf\u8be5\u51fd\u6570\u5728\u5904\u7406\u76f8\u4f3c\u4e8b\u4ef6\u7684\u65f6\u5019\u53ef\u4ee5\u7075\u6d3b\u7684\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u6cd5\u3002","title":"\u4f18\u70b9"},{"location":"Core/EventsSystem/#virtual","text":"\u5728\u6ca1\u6709 virtual \u7684\u60c5\u51b5\u4e0b\uff0c\u4ee5\u57fa\u7c7b\u6307\u9488\u8c03\u7528\u65f6\u7f16\u8bd1\u5668\u5e76\u4e0d\u77e5\u9053\u6bd4\u57fa\u7c7b\u66f4\u591a\u7684\u4e1c\u897f\uff0c\u901a\u5e38\u8c03\u7528\u51fd\u6570\u7684\u57fa\u7c7b\u7248\u672c\uff1b \u5f53\u7528 virtual \u58f0\u660e\u51fd\u6570\u65f6\uff0c\u6bcf\u5f53\u521b\u5efa\u4e00\u4e2a\u5305\u542b\u865a\u51fd\u6570\u7684\u7c7b\u6216\u8005\u4ece\u5305\u542b\u865a\u51fd\u6570\u7684\u7c7b\u6d3e\u751f\u7684\u7c7b\u65f6\uff0c\u7f16\u8bd1\u5668\u5c31\u521b\u5efa\u4e00\u4e2a VTABLE \uff1b \u5982\u679c\u6d3e\u751f\u7c7b\u6ca1\u6709\u5bf9\u57fa\u7c7b\u7684 virtual \u51fd\u6570\u8fdb\u884c\u91cd\u65b0\u5b9a\u4e49\uff0c VTABLE \u4e2d\u5c31\u586b\u5145\u57fa\u7c7b\u7684\u865a\u51fd\u6570\u7684\u5730\u5740\uff1b \u7f16\u8bd1\u5668\u4f1a\u5728\u7c7b\u4e2d\u653e\u7f6e\u4e00\u4e2a VPTR \uff0c VPTR \u6307\u5411\u76f8\u5e94\u7684 VTABLE \uff0c VPTR \u7684\u521d\u59cb\u5316\u5728\u6784\u9020\u51fd\u6570\u4e2d\u5b8c\u6210\u3002 \u6211\u7684\u7406\u89e3\u662f\uff0c\u7236\u7c7b\u7684\u6240\u6709\u865a\u51fd\u6570\u4f1a\u88ab\u6c47\u603b\u6210\u4e00\u5f20\u8868\uff0c\u5b50\u7c7b\u7ee7\u627f\u65f6\u4f1a\u5f00\u8f9f\u4e00\u5757\u5185\u5b58\u653e\u7f6e\u8be5\u8868\u548c\u4e00\u4e2a\u6307\u5411\u8be5\u8868\u7684\u6307\u9488\uff0c\u5982\u679c\u91cd\u8f7d\u4e86\u5c31\u8986\u76d6\u8868\u4e2d\u76f8\u5e94\u7684\u51fd\u6570\u3002 \u503c\u5f97\u6ce8\u610f\u7684\u662f\u4e4b\u6240\u4ee5\u89c4\u5b9a\u7236\u7c7b\u7684\u6790\u6784\u51fd\u6570\u5fc5\u987b\u4e3a\u865a\u51fd\u6570\uff0c\u662f\u4e3a\u4e86\u9632\u6b62 delete \u5b50\u7c7b\u65f6\u6ca1\u6709 delete \u7236\u7c7b\uff0c\u4ece\u800c\u9020\u6210\u5185\u5b58\u6ea2\u51fa\u3002","title":"virtual"},{"location":"Core/EventsSystem/#stdunique_ptr-stdshared_ptr","text":"","title":"std::unique_ptr \u548c std::shared_ptr"},{"location":"Core/EventsSystem/#stdunique_ptr","text":"std::unique_ptr \u53ea\u5141\u8bb8\u4e00\u4e2a\u6307\u9488\u6307\u5411\u540c\u4e00\u4e2a\u5bf9\u8c61\uff0c\u6240\u4ee5\u6307\u9488\u88ab\u9500\u6bc1\u65f6\u4f1a\u81ea\u52a8\u9500\u6bc1\u5bf9\u8c61\uff0c\u53ef\u4ee5\u901a\u8fc7 std::move \u66f4\u6539\u6240\u6709\u6743\u3002 \u63a8\u8350\u4f7f\u7528 make_unique \u521b\u5efa\u4ee5\u51cf\u5c11\u4ee3\u7801\u91cd\u590d\u3002","title":"std::unique_ptr"},{"location":"Core/EventsSystem/#stdshared_ptr","text":"std::shared_ptr \u5141\u8bb8\u591a\u4e2a\u6307\u9488\u6307\u5411\u540c\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5185\u90e8\u6709\u8ba1\u6570\u5668\u8bb0\u5f55\u6307\u9488\u6570\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7 std::move \u66f4\u6539\u6240\u6709\u6743\u3002 \u63a8\u8350\u4f7f\u7528 make_shared \u521b\u5efa\u4ee5\u51cf\u5c11\u4ee3\u7801\u91cd\u590d\u3002","title":"std::shared_ptr"},{"location":"Core/EventsSystem/#vsync","text":"\u5782\u76f4\u540c\u6b65\u65e8\u5728\u89e3\u51b3\u753b\u9762\u7684 FPS \u4e0e\u663e\u793a\u5668\u7684\u5e27\u7387\u4e0d\u540c\u6b65\u7684\u95ee\u9898\uff0c\u5f53\u4e8c\u8005\u5b58\u5728\u5dee\u8ddd\u65f6\uff0c\u53ef\u80fd\u4f1a\u51fa\u73b0 Screen Tearing \uff08\u5c4f\u5e55\u6495\u626f\uff09\u7684\u60c5\u51b5\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4e0b\u9762\u7684\u56fe\u793a\u5c55\u793a\u4e86 GPU \u548c\u663e\u793a\u5668\u7ed8\u5236\u5e27\u7387\u4e0d\u540c\u6b65\u5bfc\u81f4\u5c4f\u5e55\u6495\u626f\u7684\u60c5\u51b5\u3002","title":"VSync"},{"location":"Core/EventsSystem/#_9","text":"\u964d\u4f4e GPU \u7684\u5e27\u7387\uff0c\u4f7f\u5176\u8ddf\u663e\u793a\u5668\u7684\u5e27\u7387\u4e00\u6837 \u5bf9\u4e8e\u4e00\u4e9b\u8001\u6e38\u620f\uff0c GPU \u5e27\u7387\u4f1a\u7279\u522b\u9ad8\uff0c\u8fd9\u5f88\u6d88\u8017\u6027\u80fd\uff0c\u800c\u5f00\u542f\u5782\u76f4\u540c\u6b65\u80fd\u540c\u6b65 GPU \u5e27\u7387\u5230\u663e\u793a\u5668\u7684\u5e27\u7387\uff0c\u4ece\u800c\u51cf\u5c11 GPU \u7684\u8ba1\u7b97\u91cf\u3002","title":"\u597d\u5904"},{"location":"Core/EventsSystem/#_10","text":"\u53ef\u80fd\u4f1a\u611f\u53d7\u5230 Input \u8f93\u5165\uff0c\u6bd4\u5982\u9f20\u6807\u548c\u952e\u76d8\u8f93\u5165\u7684\u5ef6\u8fdf\uff08\u4fd7\u79f0\u4e0d\u8ddf\u624b\uff09\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u7684\u533a\u95f4\u8f93\u5165\u952e\u76d8\u4f1a\u5ef6\u8fdf\u5230\u4e0b\u4e00\u5e27\u3002","title":"\u574f\u5904"},{"location":"Core/EventsSystem/#_11","text":"#define \u3002 std::function \u3002 std::bind \u3002 CallBack \u3002 virtual \u3002 std::make_unique unique_ptr make_shared \u3002 VSync \u3002","title":"\u8d44\u6599\u6765\u6e90"},{"location":"Core/InputPolling/","text":"\u7ed3\u6784 \u4f18\u70b9 \u5728\u4e0d\u540c\u5e73\u53f0\u4e0b\u5c06\u5b9e\u73b0\u51fd\u6570\u91cd\u8f7d\uff0c\u518d\u4ea4\u7531\u6807\u51c6\u51fd\u6570\u7edf\u4e00\u8c03\u7528\u3002 Input Input \uff1a\u4f5c\u4e3a\u57fa\u7c7b\uff0c\u63d0\u4f9b\u4e86\u516c\u6709\u7684\u6807\u51c6\u51fd\u6570\u63a5\u53e3\uff08\u65b9\u4fbf\u8c03\u7528\uff09\u548c\u5b9e\u73b0\u51fd\u6570\u63a5\u53e3\uff08\u91cd\u8f7d\uff09\u3002 class HAZEL_API Input { public: inline static bool IsKeyPressed(int keycode) { return s_Instance->IsKeyPressedImpl(keycode); } inline static bool IsMouseButtonPressed(int button) { return s_Instance->IsMouseButtonPressedImpl(button); } inline static std::pair<float, float> GetMousePosition() { return s_Instance->GetMousePositionImpl(); } inline static float GetMouseX() { return s_Instance->GetMouseXImpl(); } inline static float GetMouseY() { return s_Instance->GetMouseYImpl(); } protected: virtual bool IsKeyPressedImpl(int keycode) = 0; virtual bool IsMouseButtonPressedImpl(int button) = 0; virtual std::pair<float, float> GetMousePositionImpl() = 0; virtual float GetMouseXImpl() = 0; virtual float GetMouseYImpl() = 0; private: static Input* s_Instance; }; WindowsInput WindowsInput \uff1a\u5229\u7528 GLFW \u91cd\u8f7d\u4e86\u5b9e\u73b0\u51fd\u6570\u3002 class HAZEL_API Input { public: inline static bool IsKeyPressed(int keycode) { return s_Instance->IsKeyPressedImpl(keycode); } inline static bool IsMouseButtonPressed(int button) { return s_Instance->IsMouseButtonPressedImpl(button); } inline static std::pair<float, float> GetMousePosition() { return s_Instance->GetMousePositionImpl(); } inline static float GetMouseX() { return s_Instance->GetMouseXImpl(); } inline static float GetMouseY() { return s_Instance->GetMouseYImpl(); } protected: virtual bool IsKeyPressedImpl(int keycode) = 0; virtual bool IsMouseButtonPressedImpl(int button) = 0; virtual std::pair<float, float> GetMousePositionImpl() = 0; virtual float GetMouseXImpl() = 0; virtual float GetMouseYImpl() = 0; private: static Input* s_Instance; }; \u8865\u5145\u77e5\u8bc6 static \u7236\u7c7b\u4e2d\u88ab static \u4fee\u9970\u7684\u5bf9\u8c61\u5728\u7ee7\u627f\u540e\u4e0d\u4f1a\u6539\u53d8\u5176\u8bbf\u95ee\u6743\u9650\u3002 \u8d44\u6599\u6765\u6e90 static \u3002","title":"\u8f93\u5165\u6c60"},{"location":"Core/InputPolling/#_1","text":"","title":"\u7ed3\u6784"},{"location":"Core/InputPolling/#_2","text":"\u5728\u4e0d\u540c\u5e73\u53f0\u4e0b\u5c06\u5b9e\u73b0\u51fd\u6570\u91cd\u8f7d\uff0c\u518d\u4ea4\u7531\u6807\u51c6\u51fd\u6570\u7edf\u4e00\u8c03\u7528\u3002","title":"\u4f18\u70b9"},{"location":"Core/InputPolling/#input","text":"Input \uff1a\u4f5c\u4e3a\u57fa\u7c7b\uff0c\u63d0\u4f9b\u4e86\u516c\u6709\u7684\u6807\u51c6\u51fd\u6570\u63a5\u53e3\uff08\u65b9\u4fbf\u8c03\u7528\uff09\u548c\u5b9e\u73b0\u51fd\u6570\u63a5\u53e3\uff08\u91cd\u8f7d\uff09\u3002 class HAZEL_API Input { public: inline static bool IsKeyPressed(int keycode) { return s_Instance->IsKeyPressedImpl(keycode); } inline static bool IsMouseButtonPressed(int button) { return s_Instance->IsMouseButtonPressedImpl(button); } inline static std::pair<float, float> GetMousePosition() { return s_Instance->GetMousePositionImpl(); } inline static float GetMouseX() { return s_Instance->GetMouseXImpl(); } inline static float GetMouseY() { return s_Instance->GetMouseYImpl(); } protected: virtual bool IsKeyPressedImpl(int keycode) = 0; virtual bool IsMouseButtonPressedImpl(int button) = 0; virtual std::pair<float, float> GetMousePositionImpl() = 0; virtual float GetMouseXImpl() = 0; virtual float GetMouseYImpl() = 0; private: static Input* s_Instance; };","title":"Input"},{"location":"Core/InputPolling/#windowsinput","text":"WindowsInput \uff1a\u5229\u7528 GLFW \u91cd\u8f7d\u4e86\u5b9e\u73b0\u51fd\u6570\u3002 class HAZEL_API Input { public: inline static bool IsKeyPressed(int keycode) { return s_Instance->IsKeyPressedImpl(keycode); } inline static bool IsMouseButtonPressed(int button) { return s_Instance->IsMouseButtonPressedImpl(button); } inline static std::pair<float, float> GetMousePosition() { return s_Instance->GetMousePositionImpl(); } inline static float GetMouseX() { return s_Instance->GetMouseXImpl(); } inline static float GetMouseY() { return s_Instance->GetMouseYImpl(); } protected: virtual bool IsKeyPressedImpl(int keycode) = 0; virtual bool IsMouseButtonPressedImpl(int button) = 0; virtual std::pair<float, float> GetMousePositionImpl() = 0; virtual float GetMouseXImpl() = 0; virtual float GetMouseYImpl() = 0; private: static Input* s_Instance; };","title":"WindowsInput"},{"location":"Core/InputPolling/#_3","text":"","title":"\u8865\u5145\u77e5\u8bc6"},{"location":"Core/InputPolling/#static","text":"\u7236\u7c7b\u4e2d\u88ab static \u4fee\u9970\u7684\u5bf9\u8c61\u5728\u7ee7\u627f\u540e\u4e0d\u4f1a\u6539\u53d8\u5176\u8bbf\u95ee\u6743\u9650\u3002","title":"static"},{"location":"Core/InputPolling/#_4","text":"static \u3002","title":"\u8d44\u6599\u6765\u6e90"},{"location":"Core/LayersSystem/","text":"\u7528\u5904 \u5c06\u4e0d\u540c\u7684\u5185\u5bb9\u5206\u914d\u81f3\u4e0d\u540c\u7684\u5c42\u4e2d\uff0c\u518d\u6309\u7167\u7279\u5b9a\u7684\u6e32\u67d3\u987a\u5e8f\u8f93\u51fa\u81f3\u5c4f\u5e55\u4e0a\u3002 \u7ed3\u6784 \u4f18\u70b9 \u66f4\u597d\u7684\u5b9e\u73b0\u5206\u5c42\u7ba1\u7406\u3002 Layer Layer \uff1a\u4f5c\u4e3a\u57fa\u7c7b\uff0c\u56ca\u62ec\u4e86\u5c42\u6240\u9700\u7684\u57fa\u672c\u529f\u80fd\uff08\u4e8b\u4ef6\u76d1\u542c\u548c\u5185\u5bb9\u66f4\u65b0\uff09\u3002 class HAZEL_API Layer { public: Layer(const std::string& name = \"Layer\"); virtual ~Layer(); virtual void OnAttach() {} virtual void OnDetach() {} virtual void OnUpdate() {} virtual void OnEvent(Event& event) {} inline const std::string& GetName() const { return m_DebugName; } protected: std::string m_DebugName; }; LayerStack LayerStack \uff1a\u50a8\u5b58\u7ba1\u7406\u6240\u6709\u7684\u5c42\u3002 class HAZEL_API LayerStack { public: LayerStack(); ~LayerStack(); void PushLayer(Layer* layer); void PushOverlay(Layer* overlay); void PopLayer(Layer* layer); void PopOverlay(Layer* overlay); std::vector<Layer*>::iterator begin() { return m_Layers.begin(); } std::vector<Layer*>::iterator end() { return m_Layers.end(); } private: std::vector<Layer*> m_Layers; std::vector<Layer*>::iterator m_LayerInsert; }; \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u6700\u9876\u7684\u5c42\u6700\u5148\u63a5\u6536\u4e8b\u4ef6\uff0c\u6700\u665a\u88ab\u6e32\u67d3\uff08\u8986\u76d6\u5176\u4ed6\u5c42\uff09\u3002","title":"\u5c42\u7ea7\u7cfb\u7edf"},{"location":"Core/LayersSystem/#_1","text":"\u5c06\u4e0d\u540c\u7684\u5185\u5bb9\u5206\u914d\u81f3\u4e0d\u540c\u7684\u5c42\u4e2d\uff0c\u518d\u6309\u7167\u7279\u5b9a\u7684\u6e32\u67d3\u987a\u5e8f\u8f93\u51fa\u81f3\u5c4f\u5e55\u4e0a\u3002","title":"\u7528\u5904"},{"location":"Core/LayersSystem/#_2","text":"","title":"\u7ed3\u6784"},{"location":"Core/LayersSystem/#_3","text":"\u66f4\u597d\u7684\u5b9e\u73b0\u5206\u5c42\u7ba1\u7406\u3002","title":"\u4f18\u70b9"},{"location":"Core/LayersSystem/#layer","text":"Layer \uff1a\u4f5c\u4e3a\u57fa\u7c7b\uff0c\u56ca\u62ec\u4e86\u5c42\u6240\u9700\u7684\u57fa\u672c\u529f\u80fd\uff08\u4e8b\u4ef6\u76d1\u542c\u548c\u5185\u5bb9\u66f4\u65b0\uff09\u3002 class HAZEL_API Layer { public: Layer(const std::string& name = \"Layer\"); virtual ~Layer(); virtual void OnAttach() {} virtual void OnDetach() {} virtual void OnUpdate() {} virtual void OnEvent(Event& event) {} inline const std::string& GetName() const { return m_DebugName; } protected: std::string m_DebugName; };","title":"Layer"},{"location":"Core/LayersSystem/#layerstack","text":"LayerStack \uff1a\u50a8\u5b58\u7ba1\u7406\u6240\u6709\u7684\u5c42\u3002 class HAZEL_API LayerStack { public: LayerStack(); ~LayerStack(); void PushLayer(Layer* layer); void PushOverlay(Layer* overlay); void PopLayer(Layer* layer); void PopOverlay(Layer* overlay); std::vector<Layer*>::iterator begin() { return m_Layers.begin(); } std::vector<Layer*>::iterator end() { return m_Layers.end(); } private: std::vector<Layer*> m_Layers; std::vector<Layer*>::iterator m_LayerInsert; }; \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u6700\u9876\u7684\u5c42\u6700\u5148\u63a5\u6536\u4e8b\u4ef6\uff0c\u6700\u665a\u88ab\u6e32\u67d3\uff08\u8986\u76d6\u5176\u4ed6\u5c42\uff09\u3002","title":"LayerStack"},{"location":"Core/Math/","text":"\u7ed3\u6784 \u7528\u4e86 glm \u4f5c\u4e3a\u6570\u5b66\u5e93\u3002","title":"\u6570\u5b66"},{"location":"Core/Math/#_1","text":"\u7528\u4e86 glm \u4f5c\u4e3a\u6570\u5b66\u5e93\u3002","title":"\u7ed3\u6784"},{"location":"Core/Timer/","text":"\u7ed3\u6784 \u8ba1\u65f6\u5668\u3002 class Timer { public: Timer() { Reset(); } void Timer::Reset() { m_Start = std::chrono::high_resolution_clock::now(); } float Timer::Elapsed() { return std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now() - m_Start).count() * 0.001f * 0.001f * 0.001f; } float Timer::ElapsedMillis() { return Elapsed() * 1000.0f; } private: std::chrono::time_point<std::chrono::high_resolution_clock> m_Start; }; \u8865\u5145\u77e5\u8bc6 lambda lambda \u8868\u8fbe\u5f0f\u5b9a\u4e49\u4e86\u4e00\u4e2a\u533f\u540d\u51fd\u6570\uff0c\u5e76\u4e14\u53ef\u4ee5\u6355\u83b7\u4e00\u5b9a\u8303\u56f4\u5185\u7684\u53d8\u91cf\u3002 lambda \u8868\u8fbe\u5f0f\u7684\u8bed\u6cd5\u5f62\u5f0f\u53ef\u7b80\u5355\u5f52\u7eb3\u5982\u4e0b\u3002 [ capture ] ( params ) opt -> ret { body; }; \u5176\u4e2d capture \u53d6\u4e0d\u540c\u7684\u503c\u6709\u4e0d\u540c\u7684\u542b\u4e49\u3002 [] \u4e0d\u6355\u83b7\u4efb\u4f55\u53d8\u91cf\uff1b [&] \u6355\u83b7\u5916\u90e8\u4f5c\u7528\u57df\u4e2d\u6240\u6709\u53d8\u91cf\uff0c\u5e76\u4f5c\u4e3a\u5f15\u7528\u5728\u51fd\u6570\u4f53\u4e2d\u4f7f\u7528\uff08\u6309\u5f15\u7528\u6355\u83b7\uff09\uff1b [=] \u6355\u83b7\u5916\u90e8\u4f5c\u7528\u57df\u4e2d\u6240\u6709\u53d8\u91cf\uff0c\u5e76\u4f5c\u4e3a\u526f\u672c\u5728\u51fd\u6570\u4f53\u4e2d\u4f7f\u7528\uff08\u6309\u503c\u6355\u83b7\uff09\uff1b [=\uff0c&foo] \u6309\u503c\u6355\u83b7\u5916\u90e8\u4f5c\u7528\u57df\u4e2d\u6240\u6709\u53d8\u91cf\uff0c\u5e76\u6309\u5f15\u7528\u6355\u83b7 foo \u53d8\u91cf\uff1b [bar] \u6309\u503c\u6355\u83b7 bar \u53d8\u91cf\uff0c\u540c\u65f6\u4e0d\u6355\u83b7\u5176\u4ed6\u53d8\u91cf\uff1b [this] \u6355\u83b7\u5f53\u524d\u7c7b\u4e2d\u7684 this \u6307\u9488\uff0c\u8ba9 lambda \u8868\u8fbe\u5f0f\u62e5\u6709\u548c\u5f53\u524d\u7c7b\u6210\u5458\u51fd\u6570\u540c\u6837\u7684\u8bbf\u95ee\u6743\u9650\u3002\u5982\u679c\u5df2\u7ecf\u4f7f\u7528\u4e86 & \u6216\u8005 =\uff0c\u5c31\u9ed8\u8ba4\u6dfb\u52a0\u6b64\u9009\u9879\u3002\u6355\u83b7 this \u7684\u76ee\u7684\u662f\u53ef\u4ee5\u5728 lamda \u4e2d\u4f7f\u7528\u5f53\u524d\u7c7b\u7684\u6210\u5458\u51fd\u6570\u548c\u6210\u5458\u53d8\u91cf\u3002 class A { public: int i_ = 0; void func(int x, int y) { auto x1 = []{ return i_; }; // error\uff0c\u6ca1\u6709\u6355\u83b7\u5916\u90e8\u53d8\u91cf auto x2 = [=]{ return i_ + x + y; }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf auto x3 = [&]{ return i_ + x + y; }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf auto x4 = [this]{ return i_; }; // OK\uff0c\u6355\u83b7this\u6307\u9488 auto x5 = [this]{ return i_ + x + y; }; // error\uff0c\u6ca1\u6709\u6355\u83b7x\u3001y auto x6 = [this, x, y]{ return i_ + x + y; }; // OK\uff0c\u6355\u83b7this\u6307\u9488\u3001x\u3001y auto x7 = [this]{ return i_++; }; // OK\uff0c\u6355\u83b7this\u6307\u9488\uff0c\u5e76\u4fee\u6539\u6210\u5458\u7684\u503c } }; int a = 0, b = 1; auto f1 = []{ return a; }; // error\uff0c\u6ca1\u6709\u6355\u83b7\u5916\u90e8\u53d8\u91cf auto f2 = [&]{ return a++; }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf\uff0c\u5e76\u5bf9a\u6267\u884c\u81ea\u52a0\u8fd0\u7b97 auto f3 = [=]{ return a; }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf\uff0c\u5e76\u8fd4\u56dea auto f4 = [=]{ return a++; }; // error\uff0ca\u662f\u4ee5\u590d\u5236\u65b9\u5f0f\u6355\u83b7\u7684\uff0c\u65e0\u6cd5\u4fee\u6539 auto f5 = [a]{ return a + b; }; // error\uff0c\u6ca1\u6709\u6355\u83b7\u53d8\u91cfb auto f6 = [a, &b]{ return a + (b++); }; // OK\uff0c\u6355\u83b7a\u548cb\u7684\u5f15\u7528\uff0c\u5e76\u5bf9b\u505a\u81ea\u52a0\u8fd0\u7b97 auto f7 = [=, &b]{ return a + (b++); }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf\u548cb\u7684\u5f15\u7528\uff0c\u5e76\u5bf9b\u505a\u81ea\u52a0\u8fd0\u7b97 \u8d44\u6599\u6765\u6e90 lambda \u3002","title":"\u8ba1\u65f6\u5668"},{"location":"Core/Timer/#_1","text":"\u8ba1\u65f6\u5668\u3002 class Timer { public: Timer() { Reset(); } void Timer::Reset() { m_Start = std::chrono::high_resolution_clock::now(); } float Timer::Elapsed() { return std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now() - m_Start).count() * 0.001f * 0.001f * 0.001f; } float Timer::ElapsedMillis() { return Elapsed() * 1000.0f; } private: std::chrono::time_point<std::chrono::high_resolution_clock> m_Start; };","title":"\u7ed3\u6784"},{"location":"Core/Timer/#_2","text":"","title":"\u8865\u5145\u77e5\u8bc6"},{"location":"Core/Timer/#lambda","text":"lambda \u8868\u8fbe\u5f0f\u5b9a\u4e49\u4e86\u4e00\u4e2a\u533f\u540d\u51fd\u6570\uff0c\u5e76\u4e14\u53ef\u4ee5\u6355\u83b7\u4e00\u5b9a\u8303\u56f4\u5185\u7684\u53d8\u91cf\u3002 lambda \u8868\u8fbe\u5f0f\u7684\u8bed\u6cd5\u5f62\u5f0f\u53ef\u7b80\u5355\u5f52\u7eb3\u5982\u4e0b\u3002 [ capture ] ( params ) opt -> ret { body; }; \u5176\u4e2d capture \u53d6\u4e0d\u540c\u7684\u503c\u6709\u4e0d\u540c\u7684\u542b\u4e49\u3002 [] \u4e0d\u6355\u83b7\u4efb\u4f55\u53d8\u91cf\uff1b [&] \u6355\u83b7\u5916\u90e8\u4f5c\u7528\u57df\u4e2d\u6240\u6709\u53d8\u91cf\uff0c\u5e76\u4f5c\u4e3a\u5f15\u7528\u5728\u51fd\u6570\u4f53\u4e2d\u4f7f\u7528\uff08\u6309\u5f15\u7528\u6355\u83b7\uff09\uff1b [=] \u6355\u83b7\u5916\u90e8\u4f5c\u7528\u57df\u4e2d\u6240\u6709\u53d8\u91cf\uff0c\u5e76\u4f5c\u4e3a\u526f\u672c\u5728\u51fd\u6570\u4f53\u4e2d\u4f7f\u7528\uff08\u6309\u503c\u6355\u83b7\uff09\uff1b [=\uff0c&foo] \u6309\u503c\u6355\u83b7\u5916\u90e8\u4f5c\u7528\u57df\u4e2d\u6240\u6709\u53d8\u91cf\uff0c\u5e76\u6309\u5f15\u7528\u6355\u83b7 foo \u53d8\u91cf\uff1b [bar] \u6309\u503c\u6355\u83b7 bar \u53d8\u91cf\uff0c\u540c\u65f6\u4e0d\u6355\u83b7\u5176\u4ed6\u53d8\u91cf\uff1b [this] \u6355\u83b7\u5f53\u524d\u7c7b\u4e2d\u7684 this \u6307\u9488\uff0c\u8ba9 lambda \u8868\u8fbe\u5f0f\u62e5\u6709\u548c\u5f53\u524d\u7c7b\u6210\u5458\u51fd\u6570\u540c\u6837\u7684\u8bbf\u95ee\u6743\u9650\u3002\u5982\u679c\u5df2\u7ecf\u4f7f\u7528\u4e86 & \u6216\u8005 =\uff0c\u5c31\u9ed8\u8ba4\u6dfb\u52a0\u6b64\u9009\u9879\u3002\u6355\u83b7 this \u7684\u76ee\u7684\u662f\u53ef\u4ee5\u5728 lamda \u4e2d\u4f7f\u7528\u5f53\u524d\u7c7b\u7684\u6210\u5458\u51fd\u6570\u548c\u6210\u5458\u53d8\u91cf\u3002 class A { public: int i_ = 0; void func(int x, int y) { auto x1 = []{ return i_; }; // error\uff0c\u6ca1\u6709\u6355\u83b7\u5916\u90e8\u53d8\u91cf auto x2 = [=]{ return i_ + x + y; }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf auto x3 = [&]{ return i_ + x + y; }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf auto x4 = [this]{ return i_; }; // OK\uff0c\u6355\u83b7this\u6307\u9488 auto x5 = [this]{ return i_ + x + y; }; // error\uff0c\u6ca1\u6709\u6355\u83b7x\u3001y auto x6 = [this, x, y]{ return i_ + x + y; }; // OK\uff0c\u6355\u83b7this\u6307\u9488\u3001x\u3001y auto x7 = [this]{ return i_++; }; // OK\uff0c\u6355\u83b7this\u6307\u9488\uff0c\u5e76\u4fee\u6539\u6210\u5458\u7684\u503c } }; int a = 0, b = 1; auto f1 = []{ return a; }; // error\uff0c\u6ca1\u6709\u6355\u83b7\u5916\u90e8\u53d8\u91cf auto f2 = [&]{ return a++; }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf\uff0c\u5e76\u5bf9a\u6267\u884c\u81ea\u52a0\u8fd0\u7b97 auto f3 = [=]{ return a; }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf\uff0c\u5e76\u8fd4\u56dea auto f4 = [=]{ return a++; }; // error\uff0ca\u662f\u4ee5\u590d\u5236\u65b9\u5f0f\u6355\u83b7\u7684\uff0c\u65e0\u6cd5\u4fee\u6539 auto f5 = [a]{ return a + b; }; // error\uff0c\u6ca1\u6709\u6355\u83b7\u53d8\u91cfb auto f6 = [a, &b]{ return a + (b++); }; // OK\uff0c\u6355\u83b7a\u548cb\u7684\u5f15\u7528\uff0c\u5e76\u5bf9b\u505a\u81ea\u52a0\u8fd0\u7b97 auto f7 = [=, &b]{ return a + (b++); }; // OK\uff0c\u6355\u83b7\u6240\u6709\u5916\u90e8\u53d8\u91cf\u548cb\u7684\u5f15\u7528\uff0c\u5e76\u5bf9b\u505a\u81ea\u52a0\u8fd0\u7b97","title":"lambda"},{"location":"Core/Timer/#_3","text":"lambda \u3002","title":"\u8d44\u6599\u6765\u6e90"},{"location":"Core/Timestep/","text":"\u7528\u5904 \u5b9e\u73b0\u7a33\u5b9a\u7684\u65f6\u95f4\u6b65\u957f\u3002 \u7ed3\u6784 \u5c06\u6bcf\u4e00\u5e27\u91cc\u5bf9\u8c61\u7684\u8fd0\u52a8\u901f\u5ea6\u4e0e\u8be5\u5e27\u7684\u6e32\u67d3\u65f6\u95f4\u76f8\u4e58\uff0c\u5c31\u53ef\u4ee5\u62b5\u6d88\u5728\u4e0d\u540c\u8fd0\u884c\u73af\u5883\u4e0b\u56e0\u4e3a\u5e27\u7387\u800c\u9020\u6210\u7684\u6570\u636e\u5dee\u5f02\u3002 class Timestep { public: Timestep(float time = 0.0f) : m_Time(time) { } operator float() const { return m_Time; } float GetSeconds() const { return m_Time; } float GetMilliseconds() const { return m_Time * 1000.0f; } private: float m_Time; }; \u8865\u5145\u77e5\u8bc6 \u4e09\u79cd Timestep \u7cfb\u7edf Fixed delta time double t = 0.0; double dt = 1.0 / 60.0; while (!quit) { integrate(state, t, dt); render(state); t += dt; } \u8fd9\u79cd\u4ee3\u7801\u4e00\u822c\u662f\u542f\u7528 VSync \u65f6\u8c03\u7528\u7684\uff0c\u56e0\u4e3a\u6b64\u65f6\u5df2\u7ecf\u77e5\u9053\u8c03\u7528\u6e32\u67d3 Loop \u7684\u9891\u7387\uff0c\u6bd4\u5982\u8fd9\u91cc\u663e\u793a\u5668\u662f 60 \u7684\u5e27\u7387\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd9\u4e48\u5199\u3002 \u4f46\u8fd9\u6837\u5199\u4e5f\u4e0d\u592a\u597d\uff0c\u56e0\u4e3a\u5b83\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff1a\u5982\u679c CPU \u6e32\u67d3\u7684\u9891\u7387\u8ddf\u4e0d\u4e0a\u663e\u793a\u5668\u7684\u9891\u7387\uff0c\u90a3\u4e48\u8fd9\u91cc\u7684\u51fd\u6570\u4e00\u79d2\u5c31\u4e0d\u80fd\u8dd1\u5230 60 \u6b21\uff0c\u6e38\u620f\u91cc\u7684\u903b\u8f91\u5c31\u4f1a\u53d8\u6162\u3002\u800c\u4e14\u5982\u679c\u6ca1\u5f00 VSync \uff0c\u4e5f\u4f1a\u6709\u95ee\u9898\u3002 Variable delta time \u5982\u4e0a\u3002 \u4e0d\u8fc7\u8fd9\u79cd\u65b9\u6cd5\uff0c\u5982\u679c\u673a\u5668\u5f88\u5dee\u7684\u8bdd\uff0c\u5e27\u4e0e\u5e27\u4e4b\u95f4\u7684 delta time \u4e0d\u4ec5\u53ef\u80fd\u4f1a\u5f88\u5927\uff0c\u800c\u4e14\u6bcf\u5e27\u7684 delta time \u90fd\u662f\u4e0d\u540c\u7684\u3002 \u800c\u5bf9\u4e8e\u7269\u7406\u6a21\u62df\u7684\u7cfb\u7edf\u6765\u8bf4\uff0c\u9700\u8981\u7684\u662f\u7a33\u5b9a\u4e0d\u53d8\uff0c\u4e14\u8f83\u5c0f\u7684 delta time \uff0c\u53ea\u6709\u8fd9\u6837\uff0c\u624d\u80fd\u5e73\u6ed1\u7684\u8ba1\u7b97\u7269\u7406\u4e4b\u95f4\u7684\u53d8\u5316\u3002 Semi-fixed timestep \u7c7b\u4f3c\u4e8e Unity \u7684 FixedUpdate \u51fd\u6570\uff0c Unity \u91cc\u7684 Update \u51fd\u6570\u662f\u6bcf\u5e27\u6267\u884c\u4e00\u6b21\u7684\u51fd\u6570\uff0c\u800c FixedUpdate \u6bcf\u5e27\u53ef\u4ee5\u6267\u884c\u4efb\u610f\u591a\u7684\u6b21\u6570\uff0c\u8fd9\u53d6\u51b3\u4e8e Unity \u7684 time \u76f8\u5173\u7684\u8bbe\u7f6e\u4e0e\u6e38\u620f\u91cc\u5b9e\u9645\u7684 framerate \uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002 FixedUpdate is used when you need to have something persistently cleanly applying at the same rate, and that\u2019s usually physics, because physics needs to calculate stuff using time as an actual parameter. \u521d\u6b65\u601d\u8def\u662f\uff0c\u5f53\u4e00\u5e27\u6240\u7528\u65f6\u957f\uff0c\u5373 DeltaTime \u5927\u4e8e\u89c4\u5b9a\u7684\u6bcf\u5e27\u7684\u6700\u5927\u503c\u65f6\uff0c\u5728\u8be5\u5e27\u591a\u6b21\u5904\u7406 DeltaTime \uff0c\u7c7b\u4f3c\u4e8e\u8865\u5e27\u64cd\u4f5c\uff0c\u628a DeltaTime \u7ec6\u5316\u4e3a\u591a\u4e2a\u66f4\u5c0f\u7684 DeltaTime \uff0c\u76f8\u5173\u4ee3\u7801\u5982\u4e0b\uff1a double t = 0.0; double dt = 1 / 60.0;// \u8fd9\u662f\u4e00\u4e2a\u5e38\u91cf, \u4ee3\u8868delta time\u7684\u6700\u5927\u503c double currentTime = hires_time_in_seconds(); while (!quit) { // \u83b7\u53d6\u4e0a\u4e00\u5e27\u5230\u8fd9\u91cc\u7684delta time double newTime = hires_time_in_seconds(); double frameTime = newTime - currentTime; currentTime = newTime; // \u6ce8\u610f\u8fd9\u91cc\u7684\u5faa\u73af, \u5f53frameTime\u5927\u4e8e1/60\u65f6, \u8fd9\u91cc\u4f1a\u989d\u5916\u8dd1\u51e0\u6b21\u8fd9\u4e2a\u5faa\u73af // \u5b83\u76f8\u5f53\u4e8e\u628aframeTime\u7ec6\u5206\u4e3a\u4e86\u591a\u4e2aTimestep, \u4f46\u90fd\u5728\u8fd9\u4e00\u5e27\u5185\u6267\u884c while (frameTime > 0.0) { float deltaTime = min(frameTime, dt);// delta time\u4e0d\u5141\u8bb8\u8d85\u8fc71/60 // integrate(state, t, deltaTime); frameTime -= deltaTime; // t\u5e94\u8be5\u662f\u771f\u5b9e\u7684\u5f53\u524d\u7ecf\u5386\u7684\u65f6\u95f4 t += deltaTime; } render(state); } \u8fd9\u6837\u5199\u4e5f\u4f1a\u6709\u4e00\u4e2a\u7f3a\u70b9\uff0c\u5982\u679c\u8fd9\u91cc\u7684 Integrate \u91cc\u7684\u5185\u5bb9 CPU \u6d88\u8017\u5f88\u9ad8\u7684\u8bdd\uff0c\u5bb9\u6613\u9677\u5165 Spiral Of Death \uff0c\u7ffb\u8bd1\u8fc7\u6765\u5c31\u662f\u5faa\u73af\u6b7b\u4ea1\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5f53\u524d\u9762\u4ee3\u7801\u7684 integrate \u51fd\u6570\uff0c\u65e0\u6cd5\u5728\u7ed9\u5b83\u5206\u914d\u7684 frameTime \u91cc\u5b8c\u6210\u65f6\uff0c\u5c31\u4f1a\u9677\u5165\u65e0\u5c3d\u7684\u5faa\u73af \u8d44\u6599\u6765\u6e90 \u65f6\u95f4\u6b65\u957f\u3002","title":"\u65f6\u95f4\u6b65\u957f"},{"location":"Core/Timestep/#_1","text":"\u5b9e\u73b0\u7a33\u5b9a\u7684\u65f6\u95f4\u6b65\u957f\u3002","title":"\u7528\u5904"},{"location":"Core/Timestep/#_2","text":"\u5c06\u6bcf\u4e00\u5e27\u91cc\u5bf9\u8c61\u7684\u8fd0\u52a8\u901f\u5ea6\u4e0e\u8be5\u5e27\u7684\u6e32\u67d3\u65f6\u95f4\u76f8\u4e58\uff0c\u5c31\u53ef\u4ee5\u62b5\u6d88\u5728\u4e0d\u540c\u8fd0\u884c\u73af\u5883\u4e0b\u56e0\u4e3a\u5e27\u7387\u800c\u9020\u6210\u7684\u6570\u636e\u5dee\u5f02\u3002 class Timestep { public: Timestep(float time = 0.0f) : m_Time(time) { } operator float() const { return m_Time; } float GetSeconds() const { return m_Time; } float GetMilliseconds() const { return m_Time * 1000.0f; } private: float m_Time; };","title":"\u7ed3\u6784"},{"location":"Core/Timestep/#_3","text":"","title":"\u8865\u5145\u77e5\u8bc6"},{"location":"Core/Timestep/#timestep","text":"","title":"\u4e09\u79cd Timestep \u7cfb\u7edf"},{"location":"Core/Timestep/#fixed-delta-time","text":"double t = 0.0; double dt = 1.0 / 60.0; while (!quit) { integrate(state, t, dt); render(state); t += dt; } \u8fd9\u79cd\u4ee3\u7801\u4e00\u822c\u662f\u542f\u7528 VSync \u65f6\u8c03\u7528\u7684\uff0c\u56e0\u4e3a\u6b64\u65f6\u5df2\u7ecf\u77e5\u9053\u8c03\u7528\u6e32\u67d3 Loop \u7684\u9891\u7387\uff0c\u6bd4\u5982\u8fd9\u91cc\u663e\u793a\u5668\u662f 60 \u7684\u5e27\u7387\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd9\u4e48\u5199\u3002 \u4f46\u8fd9\u6837\u5199\u4e5f\u4e0d\u592a\u597d\uff0c\u56e0\u4e3a\u5b83\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff1a\u5982\u679c CPU \u6e32\u67d3\u7684\u9891\u7387\u8ddf\u4e0d\u4e0a\u663e\u793a\u5668\u7684\u9891\u7387\uff0c\u90a3\u4e48\u8fd9\u91cc\u7684\u51fd\u6570\u4e00\u79d2\u5c31\u4e0d\u80fd\u8dd1\u5230 60 \u6b21\uff0c\u6e38\u620f\u91cc\u7684\u903b\u8f91\u5c31\u4f1a\u53d8\u6162\u3002\u800c\u4e14\u5982\u679c\u6ca1\u5f00 VSync \uff0c\u4e5f\u4f1a\u6709\u95ee\u9898\u3002","title":"Fixed delta time"},{"location":"Core/Timestep/#variable-delta-time","text":"\u5982\u4e0a\u3002 \u4e0d\u8fc7\u8fd9\u79cd\u65b9\u6cd5\uff0c\u5982\u679c\u673a\u5668\u5f88\u5dee\u7684\u8bdd\uff0c\u5e27\u4e0e\u5e27\u4e4b\u95f4\u7684 delta time \u4e0d\u4ec5\u53ef\u80fd\u4f1a\u5f88\u5927\uff0c\u800c\u4e14\u6bcf\u5e27\u7684 delta time \u90fd\u662f\u4e0d\u540c\u7684\u3002 \u800c\u5bf9\u4e8e\u7269\u7406\u6a21\u62df\u7684\u7cfb\u7edf\u6765\u8bf4\uff0c\u9700\u8981\u7684\u662f\u7a33\u5b9a\u4e0d\u53d8\uff0c\u4e14\u8f83\u5c0f\u7684 delta time \uff0c\u53ea\u6709\u8fd9\u6837\uff0c\u624d\u80fd\u5e73\u6ed1\u7684\u8ba1\u7b97\u7269\u7406\u4e4b\u95f4\u7684\u53d8\u5316\u3002","title":"Variable delta time"},{"location":"Core/Timestep/#semi-fixed-timestep","text":"\u7c7b\u4f3c\u4e8e Unity \u7684 FixedUpdate \u51fd\u6570\uff0c Unity \u91cc\u7684 Update \u51fd\u6570\u662f\u6bcf\u5e27\u6267\u884c\u4e00\u6b21\u7684\u51fd\u6570\uff0c\u800c FixedUpdate \u6bcf\u5e27\u53ef\u4ee5\u6267\u884c\u4efb\u610f\u591a\u7684\u6b21\u6570\uff0c\u8fd9\u53d6\u51b3\u4e8e Unity \u7684 time \u76f8\u5173\u7684\u8bbe\u7f6e\u4e0e\u6e38\u620f\u91cc\u5b9e\u9645\u7684 framerate \uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002 FixedUpdate is used when you need to have something persistently cleanly applying at the same rate, and that\u2019s usually physics, because physics needs to calculate stuff using time as an actual parameter. \u521d\u6b65\u601d\u8def\u662f\uff0c\u5f53\u4e00\u5e27\u6240\u7528\u65f6\u957f\uff0c\u5373 DeltaTime \u5927\u4e8e\u89c4\u5b9a\u7684\u6bcf\u5e27\u7684\u6700\u5927\u503c\u65f6\uff0c\u5728\u8be5\u5e27\u591a\u6b21\u5904\u7406 DeltaTime \uff0c\u7c7b\u4f3c\u4e8e\u8865\u5e27\u64cd\u4f5c\uff0c\u628a DeltaTime \u7ec6\u5316\u4e3a\u591a\u4e2a\u66f4\u5c0f\u7684 DeltaTime \uff0c\u76f8\u5173\u4ee3\u7801\u5982\u4e0b\uff1a double t = 0.0; double dt = 1 / 60.0;// \u8fd9\u662f\u4e00\u4e2a\u5e38\u91cf, \u4ee3\u8868delta time\u7684\u6700\u5927\u503c double currentTime = hires_time_in_seconds(); while (!quit) { // \u83b7\u53d6\u4e0a\u4e00\u5e27\u5230\u8fd9\u91cc\u7684delta time double newTime = hires_time_in_seconds(); double frameTime = newTime - currentTime; currentTime = newTime; // \u6ce8\u610f\u8fd9\u91cc\u7684\u5faa\u73af, \u5f53frameTime\u5927\u4e8e1/60\u65f6, \u8fd9\u91cc\u4f1a\u989d\u5916\u8dd1\u51e0\u6b21\u8fd9\u4e2a\u5faa\u73af // \u5b83\u76f8\u5f53\u4e8e\u628aframeTime\u7ec6\u5206\u4e3a\u4e86\u591a\u4e2aTimestep, \u4f46\u90fd\u5728\u8fd9\u4e00\u5e27\u5185\u6267\u884c while (frameTime > 0.0) { float deltaTime = min(frameTime, dt);// delta time\u4e0d\u5141\u8bb8\u8d85\u8fc71/60 // integrate(state, t, deltaTime); frameTime -= deltaTime; // t\u5e94\u8be5\u662f\u771f\u5b9e\u7684\u5f53\u524d\u7ecf\u5386\u7684\u65f6\u95f4 t += deltaTime; } render(state); } \u8fd9\u6837\u5199\u4e5f\u4f1a\u6709\u4e00\u4e2a\u7f3a\u70b9\uff0c\u5982\u679c\u8fd9\u91cc\u7684 Integrate \u91cc\u7684\u5185\u5bb9 CPU \u6d88\u8017\u5f88\u9ad8\u7684\u8bdd\uff0c\u5bb9\u6613\u9677\u5165 Spiral Of Death \uff0c\u7ffb\u8bd1\u8fc7\u6765\u5c31\u662f\u5faa\u73af\u6b7b\u4ea1\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5f53\u524d\u9762\u4ee3\u7801\u7684 integrate \u51fd\u6570\uff0c\u65e0\u6cd5\u5728\u7ed9\u5b83\u5206\u914d\u7684 frameTime \u91cc\u5b8c\u6210\u65f6\uff0c\u5c31\u4f1a\u9677\u5165\u65e0\u5c3d\u7684\u5faa\u73af","title":"Semi-fixed timestep"},{"location":"Core/Timestep/#_4","text":"\u65f6\u95f4\u6b65\u957f\u3002","title":"\u8d44\u6599\u6765\u6e90"},{"location":"Core/Rendering/BasicsOfGameRendering/","text":"GPU \u7684\u5de5\u4f5c \u6e32\u67d3\u7ba1\u7ebf \u6e32\u67d3\u6d41\u7a0b \u53d8\u6362\u5230\u76f8\u673a\u7684\u5750\u6807\u7cfb\u7edf\u4e2d \u8fd9\u5728 GAMES101 \u7684\u8bfe\u91cc\u90fd\u6709\u8bb2\u3002 \u63d0\u4ea4\u6570\u636e\u81f3 Shader Shader \u4e2d\u7684\u8fd0\u7b97\u6d41\u7a0b\u5c31\u662f\u6e32\u67d3\u7ba1\u7ebf\uff08\u5927\u6982\uff09\u3002 CPU \u7684\u5de5\u4f5c \u76f8\u6bd4 GPU \uff0c CPU \u4e3b\u8981\u662f\u5bf9\u62bd\u8c61\u7269\u4f53\u8fdb\u884c\u521d\u59cb\u5316\u4ee5\u53ca\u7ba1\u7406\u3002 \u62bd\u8c61\u56fe\u5f62 API \u5176\u4e2d\u5de6\u8fb9\u662f\u5e73\u53f0\u4e0d\u5173\u5fc3\u7684\uff08\u4e0d\u77e5\u9053\u7684\uff09\uff0c\u53f3\u8fb9\u662f\u9700\u8981\u6839\u636e\u5e73\u53f0\u91cd\u5199\u7684 API \u3002 \u5176\u5b9e\u901a\u8fc7\u4e4b\u524d\u7684\u4ecb\u7ecd\uff0c\u5f88\u5bb9\u6613\u53d1\u73b0\u5de6\u8fb9\u662f CPU \u7684\u5de5\u4f5c\uff0c\u53f3\u8fb9\u662f GPU \u7684\u5de5\u4f5c\uff0c\u6bd5\u7adf\u4e0d\u540c\u7684\u6e32\u67d3\u5e73\u53f0\u672c\u8eab\u5c31\u662f\u7ed9 CPU \u63d0\u4f9b\u4e86\u4e0d\u540c\u7684 RHI \u3002 Platform specific GraphicsContext \u6e32\u67d3\u8fc7\u7a0b\u4e2d\u9700\u8981\u7528\u4e0a\u4e0b\u6587\u6765\u8bb0\u5f55\u5f53\u524d\u7ebf\u7a0b\u4e2d\u4e0e\u6e32\u67d3\u76f8\u5173\u7684\u4fe1\u606f\uff0c\u65b9\u4fbf\u5728\u4e0d\u540c\u7684\u7ebf\u7a0b\u4e2d\u5207\u6362\u3002 class GraphicsContext{ public: virtual void Init() = 0; virtual void SwapBuffer() = 0; }; Shader \u5185\u90e8\u63d0\u4f9b\u4e86\u521d\u59cb\u5316\u4ee5\u53ca\u5bf9 Shade \u7684\u7ed1\u5b9a\u548c\u89e3\u7ed1\u3002 class Shader { public: Shader(const std::string& vertexSrc, const std::string& fragmentSrc); ~Shader(); void Bind() const; void Unbind() const; private: uint32_t m_RendererID; }; ShaderLibrary \u5728\u8bfb\u53d6 Shader \u6587\u4ef6\u65f6\uff0c\u5c06\u5176\u5b58\u50a8\u5728\u4e00\u4e2a map \u4e2d\uff0c\u65b9\u4fbf\u4e4b\u540e\u5bf9\u5176\u7684\u90e8\u5206\u5185\u5bb9\u8fdb\u884c\u8bbf\u95ee\u548c\u4fee\u6539\u3002 class ShaderLibrary { public: void Add(const std::string& name, const Ref<Shader>& shader); void Add(const Ref<Shader>& shader); Ref<Shader> Load(const std::string& filepath); Ref<Shader> Load(const std::string& name, const std::string& filepath); Ref<Shader> Get(const std::string& name); bool Exists(const std::string& name) const; private: std::unordered_map<std::string, Ref<Shader>> m_Shaders; }; VAO, VBO and IBO VBO VBO \u662f\u4e00\u4e2a\u5b58\u653e\u9876\u70b9\u6570\u7ec4\u7684\u7f13\u51b2\u533a\u3002 class VertexBuffer { public: virtual ~VertexBuffer() {} virtual void Bind() const = 0; virtual void Unbind() const = 0; static VertexBuffer* Create(float* vertices, uint32_t size); }; \u4ece VBO \u4e2d\u53d6\u6570\u9700\u8981\u6839\u636e\u5185\u90e8\u5b58\u50a8\u7684\u6570\u636e\u7c7b\u578b\uff0c\u8ba1\u7b97\u6570\u636e\u8d77\u59cb\u5730\u5740\u548c\u6570\u636e\u957f\u5ea6\u3002 BufferElement BufferElement \uff1a\u50a8\u5b58\u5355\u4f4d\u6570\u636e\u7684\u957f\u5ea6\u7b49\u5176\u4ed6\u5c5e\u6027\u3002 struct BufferElement { std::string Name; ShaderDataType Type; uint32_t Size; uint32_t Offset; bool Normalized; BufferElement() {} BufferElement(ShaderDataType type, const std::string& name, bool normalized = false) : Name(name), Type(type), Size(ShaderDataTypeSize(type)), Offset(0), Normalized(normalized) { } uint32_t GetComponentCount() const { switch (Type) { case ShaderDataType::Float: return 1; case ShaderDataType::Float2: return 2; case ShaderDataType::Float3: return 3; case ShaderDataType::Float4: return 4; case ShaderDataType::Mat3: return 3 * 3; case ShaderDataType::Mat4: return 4 * 4; case ShaderDataType::Int: return 1; case ShaderDataType::Int2: return 2; case ShaderDataType::Int3: return 3; case ShaderDataType::Int4: return 4; case ShaderDataType::Bool: return 1; } HZ_CORE_ASSERT(false, \"Unknown ShaderDataType!\"); return 0; } }; BufferLayout BufferLayout \uff1a\u8ba1\u7b97\u7f13\u51b2\u533a\u4e2d\u6570\u636e\u7684\u5e03\u5c40\u3002 class BufferLayout { public: BufferLayout() {} BufferLayout(const std::initializer_list<BufferElement>& elements) : m_Elements(elements) { CalculateOffsetsAndStride(); } inline uint32_t GetStride() const { return m_Stride; } inline const std::vector<BufferElement>& GetElements() const { return m_Elements; } std::vector<BufferElement>::iterator begin() { return m_Elements.begin(); } std::vector<BufferElement>::iterator end() { return m_Elements.end(); } std::vector<BufferElement>::const_iterator begin() const { return m_Elements.begin(); } std::vector<BufferElement>::const_iterator end() const { return m_Elements.end(); } private: void CalculateOffsetsAndStride() { uint32_t offset = 0; m_Stride = 0; for (auto& element : m_Elements) { element.Offset = offset; offset += element.Size; m_Stride += element.Size; } } private: std::vector<BufferElement> m_Elements; uint32_t m_Stride = 0; }; VAO VAO \u662f\u4e00\u4e2a\u5173\u4e8e\u9876\u70b9\u5c5e\u6027\u7684\u6570\u7ec4\uff0c\u6309\u5c5e\u6027\u5bf9\u5e94 VBO \uff08\u544a\u77e5 VBO \u600e\u4e48\u53d6\u6570\u636e\uff09\u3002 class VertexArray { public: virtual ~VertexArray() {} virtual void Bind() const = 0; virtual void Unbind() const = 0; virtual void AddVertexBuffer(const std::shared_ptr<VertexBuffer>& vertexBuffer) = 0; virtual void SetIndexBuffer(const std::shared_ptr<IndexBuffer>& indexBuffer) = 0; virtual const std::vector<std::shared_ptr<VertexBuffer>>& GetVertexBuffers() const = 0; virtual const std::shared_ptr<IndexBuffer>& GetIndexBuffer() const = 0; static VertexArray* Create(); }; IBO IBO \u662f\u4e00\u4e2a\u5b58\u653e\u56fe\u5143\u9876\u70b9\u5728\u9876\u70b9\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15\u7684\u7f13\u51b2\u533a\u3002 class IndexBuffer { public: virtual ~IndexBuffer() {} virtual void Bind() const = 0; virtual void Unbind() const = 0; virtual uint32_t GetCount() const = 0; static IndexBuffer* Create(uint32_t* indices, uint32_t size); }; Texture Texture \u7684\u672c\u8d28\u5c31\u662f\u4e00\u4e2a\u6570\u636e\u7f13\u51b2\u533a\uff0c\u53ea\u9700\u8981\u628a\u76f8\u5e94\u7684\u6570\u636e\u5b58\u50a8\u5728\u76f8\u5e94\u7684\u4f4d\u7f6e\uff0c\u4fbf\u53ef\u5c06\u503c\u4f20\u7ed9\u76f8\u5e94\u7684\u9876\u70b9\u3002 class Texture { public: virtual ~Texture() = default; virtual uint32_t GetWidth() const = 0; virtual uint32_t GetHeight() const = 0; virtual void Bind(uint32_t slot = 0) const = 0; }; Framebuffer \u5176\u672c\u8d28\u662f\u4e00\u5757 buffer \u533a\uff0c\u7528\u4e8e\u5b58\u50a8\u67d0\u4e00\u5e27\u6240\u6709\u7684 buffer \u6570\u636e\u3002 class Framebuffer { public: virtual void Bind() = 0; virtual void Unbind() = 0; virtual uint32_t GetColorAttachmentRendererID() const = 0; virtual const FramebufferSpecification& GetSpecification() const = 0; static Ref<Framebuffer> Create(const FramebufferSpecification& spec); }; Platform agnostic Renderer \u5305\u88c5\u6e32\u67d3\u7684\u57fa\u7840\u547d\u4ee4\uff08\u5bf9\u4e8e CPU \uff09\u3002 class Renderer { public: static void BeginScene(); static void EndScene(); static void Submit(const std::shared_ptr<VertexArray>& vertexArray); inline static RendererAPI::API GetAPI() { return RendererAPI::GetAPI(); } }; \u5176\u4e2d\uff0c BeginScene \u8d1f\u8d23\u6e32\u67d3\u524d\u7684\u73af\u5883\u8bbe\u7f6e\uff1b Submit \u4f1a\u6536\u96c6\u6e32\u67d3\u6307\u4ee4\uff0c\u5b58\u5165\u547d\u4ee4\u961f\u5217\u4e2d\uff1b EndScene \u8868\u793a\u6307\u4ee4\u6536\u96c6\u7ed3\u675f\uff0c\u5f00\u59cb\u6e32\u67d3\u3002 RenderCommand \u5305\u88c5\u6e32\u67d3\u7684\u57fa\u7840\u547d\u4ee4\uff08\u5bf9\u4e8e GPU \uff09\u3002 class RenderCommand { public: inline static void SetClearColor(const glm::vec4& color) { s_RendererAPI->SetClearColor(color); } inline static void Clear() { s_RendererAPI->Clear(); } inline static void DrawIndexed(const std::shared_ptr<VertexArray>& vertexArray) { s_RendererAPI->DrawIndexed(vertexArray); } private: static RendererAPI* s_RendererAPI; }; \u5b9e\u9645\u8fd0\u884c\u4e2d\u8fd9\u4e9b\u6e32\u67d3\u547d\u4ee4\u4f1a\u88ab\u5b58\u5165\u4e00\u4e2a\u961f\u5217\uff0c\u4ece\u800c\u4e0d\u65ad\u5730\u5411 GPU \u53d1\u9001\u6307\u4ee4\u3002 Camera OrthographicCamera \u5bf9\u4e8e\u6b63\u4ea4\u76f8\u673a\uff0c\u6211\u4eec\u9700\u8981\u6839\u636e\u5176 FOV \u7b49\u6570\u636e\u8ba1\u7b97\u57fa\u4e8e\u6b64\u76f8\u673a\u7684\u89c6\u89d2\u77e9\u9635\u548c\u6295\u5f71\u77e9\u9635\uff0c\u518d\u7b49\u8fd9\u4e9b\u6570\u636e\u4f20\u5165 Shader \u4e2d\uff0c\u4ece\u800c\u5bf9\u56fe\u5f62\u8fdb\u884c\u5750\u6807\u53d8\u6362\u3002 class OrthographicCamera { public: OrthographicCamera(float left, float right, float bottom, float top); const glm::vec3& GetPosition() const { return m_Position; } void SetPosition(const glm::vec3& position) { m_Position = position; RecalculateViewMatrix(); } float GetRotation() const { return m_Rotation; } void SetRotation(float rotation) { m_Rotation = rotation; RecalculateViewMatrix(); } const glm::mat4& GetProjectionMatrix() const { return m_ProjectionMatrix; } const glm::mat4& GetViewMatrix() const { return m_ViewMatrix; } const glm::mat4& GetViewProjectionMatrix() const { return m_ViewProjectionMatrix; } private: void RecalculateViewMatrix(); private: glm::mat4 m_ProjectionMatrix; glm::mat4 m_ViewMatrix; glm::mat4 m_ViewProjectionMatrix; glm::vec3 m_Position = { 0.0f, 0.0f, 0.0f }; float m_Rotation = 0.0f; }; \u53ef\u89c1\u6027\u88c1\u526a BVH Culling BVH Culling \u5c06\u6574\u4e2a\u7a7a\u95f4\u4e0d\u65ad\u7ec6\u5206\u6210\u4e86\u4e0d\u540c\u5927\u5c0f\u7684\u5b50\u5305\u56f4\u76d2\uff0c\u5e76\u7528\u6811\u53bb\u7ba1\u7406\u3002 BVH \u7b97\u6cd5\u5728\u5de5\u4e1a\u754c\u5e7f\u6cdb\u4f7f\u7528\uff0c\u56e0\u4e3a\u73b0\u4ee3\u6e38\u620f\u573a\u666f\u5185\u52a8\u7684\u7269\u4f53\u6bd4\u8f83\u591a\uff0c\u56e0\u6b64\u5f53\u8282\u70b9\u53d8\u52a8\u540e\uff0c\u9700\u8981\u91cd\u65b0\u6784\u5efa\u6811\u72b6\u7ed3\u6784\uff0c\u6b64\u65f6\u8981\u8003\u8651\u91cd\u65b0\u6784\u5efa\u7684\u6210\u672c\u4e00\u5b9a\u8981\u5f88\u4f4e\uff0c\u800c BVH \u6070\u597d\u5728\u6b64\u6709\u5f88\u591a\u4f18\u52bf\uff0c\u56e0\u6b64 BVH \u9002\u7528\u4e8e\u5f00\u9614\u52a8\u6001\u573a\u666f\u3002 Early-Z \u6bd4\u5f53\u524d\u5149\u6805\u4e0a\u6e32\u67d3\u7684\u56fe\u5143\u6df1\u5ea6\u66f4\u6df1\u7684\u56fe\u5143\u5c06\u4f1a\u88ab\u4e22\u5f03\u3002 \u7eb9\u7406\u538b\u7f29 \u4e3a\u4e86\u6ee1\u8db3\u968f\u673a\u8bbf\u95ee\u56fe\u7247\u50cf\u7d20\u7684\u9700\u6c42\uff0c\u6e38\u620f\u5f15\u64ce\u4e2d\u4e00\u822c\u4f7f\u7528 Block \u7684\u601d\u60f3\uff0c\u800c\u4e0d\u662f\u7528\u4f20\u7edf\u7684\u56fe\u7247\u538b\u7f29\u7b97\u6cd5\u3002 Block Compression \u4ee5 DXTC \u683c\u5f0f\u4e3e\u4f8b\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5212\u5206\u7684\u5c0f\u5757\uff0c\u53d6\u5f97\u5176\u4e2d\u6700\u4eae\u548c\u6700\u6697\u7684\u50cf\u7d20\u70b9\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u901a\u8fc7\u63d2\u503c\u5904\u7406\u4ece\u800c\u6c42\u5f97\u4e8c\u8005\u4e2d\u95f4\u4e00\u7cfb\u5217\u7684\u989c\u8272\u3002 \u5efa\u6a21 \u591a\u8fb9\u5f62\u5efa\u6a21 \u96d5\u523b \u5b9e\u4f53\u626b\u63cf \u7a0b\u5e8f\u5316\u5efa\u6a21 \u6bd4\u8f83 \u65b0\u7684\u6a21\u578b\u7ba1\u7ebf \u6838\u5fc3\u601d\u60f3\u662f\u5c06\u6a21\u578b\u5206\u6210\u591a\u4e2a Cluster \uff0c\u6839\u636e\u8fd9\u4e9b Cluster \u4e0e\u6444\u50cf\u673a\u7684\u8fdc\u8fd1\u6765\u5c55\u793a\u4e0d\u540c\u7684\u7ec6\u8282\u3002 \u8fd9\u8981\u5904\u7406\u7684\u597d\u5904\u5728\u4e8e\u3002 \u73b0\u4ee3 GPU \u5df2\u7ecf\u53ef\u4ee5\u57fa\u4e8e\u6570\u636e\uff0c\u52a8\u6001\u751f\u6210\u51e0\u4f55\u7ec6\u8282\uff0c\u800c\u4e0d\u662f\u50cf\u539f\u5148\u7684\u7ba1\u7ebf\u5c06 mesh \u6570\u636e\u4e0a\u4f20\uff1b \u5f53\u4f60\u5c06\u6bcf\u4e2a cluster \u5927\u5c0f\u786e\u5b9a\u597d\u540e\uff0c\u7531\u4e8e\u5b83\u7684\u8ba1\u7b97\u90fd\u662f\u9ad8\u6548\u4e00\u81f4\u7684\uff0c\u4ee5\u76f8\u540c\u7684 Cluster \u7ed3\u6784\u8ba9 GPU \u6765\u5e76\u884c\u5904\u7406\u65f6\uff0c\u63d0\u9ad8\u4e86\u6548\u7387\uff1b \u53ef\u4ee5\u5bf9\u6a21\u578b\u8fdb\u884c Cluster \u5254\u9664\u3002 \u8d44\u6599\u6765\u6e90 BVH Culling \u3002 Block Compression \u3002 \u65b0\u7684\u6a21\u578b\u7ba1\u7ebf\u3002","title":"\u57fa\u7840"},{"location":"Core/Rendering/BasicsOfGameRendering/#gpu","text":"","title":"GPU \u7684\u5de5\u4f5c"},{"location":"Core/Rendering/BasicsOfGameRendering/#_1","text":"","title":"\u6e32\u67d3\u7ba1\u7ebf"},{"location":"Core/Rendering/BasicsOfGameRendering/#_2","text":"","title":"\u6e32\u67d3\u6d41\u7a0b"},{"location":"Core/Rendering/BasicsOfGameRendering/#_3","text":"\u8fd9\u5728 GAMES101 \u7684\u8bfe\u91cc\u90fd\u6709\u8bb2\u3002","title":"\u53d8\u6362\u5230\u76f8\u673a\u7684\u5750\u6807\u7cfb\u7edf\u4e2d"},{"location":"Core/Rendering/BasicsOfGameRendering/#shader","text":"Shader \u4e2d\u7684\u8fd0\u7b97\u6d41\u7a0b\u5c31\u662f\u6e32\u67d3\u7ba1\u7ebf\uff08\u5927\u6982\uff09\u3002","title":"\u63d0\u4ea4\u6570\u636e\u81f3 Shader"},{"location":"Core/Rendering/BasicsOfGameRendering/#cpu","text":"\u76f8\u6bd4 GPU \uff0c CPU \u4e3b\u8981\u662f\u5bf9\u62bd\u8c61\u7269\u4f53\u8fdb\u884c\u521d\u59cb\u5316\u4ee5\u53ca\u7ba1\u7406\u3002","title":"CPU \u7684\u5de5\u4f5c"},{"location":"Core/Rendering/BasicsOfGameRendering/#api","text":"\u5176\u4e2d\u5de6\u8fb9\u662f\u5e73\u53f0\u4e0d\u5173\u5fc3\u7684\uff08\u4e0d\u77e5\u9053\u7684\uff09\uff0c\u53f3\u8fb9\u662f\u9700\u8981\u6839\u636e\u5e73\u53f0\u91cd\u5199\u7684 API \u3002 \u5176\u5b9e\u901a\u8fc7\u4e4b\u524d\u7684\u4ecb\u7ecd\uff0c\u5f88\u5bb9\u6613\u53d1\u73b0\u5de6\u8fb9\u662f CPU \u7684\u5de5\u4f5c\uff0c\u53f3\u8fb9\u662f GPU \u7684\u5de5\u4f5c\uff0c\u6bd5\u7adf\u4e0d\u540c\u7684\u6e32\u67d3\u5e73\u53f0\u672c\u8eab\u5c31\u662f\u7ed9 CPU \u63d0\u4f9b\u4e86\u4e0d\u540c\u7684 RHI \u3002","title":"\u62bd\u8c61\u56fe\u5f62 API"},{"location":"Core/Rendering/BasicsOfGameRendering/#platform-specific","text":"","title":"Platform specific"},{"location":"Core/Rendering/BasicsOfGameRendering/#graphicscontext","text":"\u6e32\u67d3\u8fc7\u7a0b\u4e2d\u9700\u8981\u7528\u4e0a\u4e0b\u6587\u6765\u8bb0\u5f55\u5f53\u524d\u7ebf\u7a0b\u4e2d\u4e0e\u6e32\u67d3\u76f8\u5173\u7684\u4fe1\u606f\uff0c\u65b9\u4fbf\u5728\u4e0d\u540c\u7684\u7ebf\u7a0b\u4e2d\u5207\u6362\u3002 class GraphicsContext{ public: virtual void Init() = 0; virtual void SwapBuffer() = 0; };","title":"GraphicsContext"},{"location":"Core/Rendering/BasicsOfGameRendering/#shader_1","text":"\u5185\u90e8\u63d0\u4f9b\u4e86\u521d\u59cb\u5316\u4ee5\u53ca\u5bf9 Shade \u7684\u7ed1\u5b9a\u548c\u89e3\u7ed1\u3002 class Shader { public: Shader(const std::string& vertexSrc, const std::string& fragmentSrc); ~Shader(); void Bind() const; void Unbind() const; private: uint32_t m_RendererID; };","title":"Shader"},{"location":"Core/Rendering/BasicsOfGameRendering/#shaderlibrary","text":"\u5728\u8bfb\u53d6 Shader \u6587\u4ef6\u65f6\uff0c\u5c06\u5176\u5b58\u50a8\u5728\u4e00\u4e2a map \u4e2d\uff0c\u65b9\u4fbf\u4e4b\u540e\u5bf9\u5176\u7684\u90e8\u5206\u5185\u5bb9\u8fdb\u884c\u8bbf\u95ee\u548c\u4fee\u6539\u3002 class ShaderLibrary { public: void Add(const std::string& name, const Ref<Shader>& shader); void Add(const Ref<Shader>& shader); Ref<Shader> Load(const std::string& filepath); Ref<Shader> Load(const std::string& name, const std::string& filepath); Ref<Shader> Get(const std::string& name); bool Exists(const std::string& name) const; private: std::unordered_map<std::string, Ref<Shader>> m_Shaders; };","title":"ShaderLibrary"},{"location":"Core/Rendering/BasicsOfGameRendering/#vao-vbo-and-ibo","text":"","title":"VAO, VBO and IBO"},{"location":"Core/Rendering/BasicsOfGameRendering/#vbo","text":"VBO \u662f\u4e00\u4e2a\u5b58\u653e\u9876\u70b9\u6570\u7ec4\u7684\u7f13\u51b2\u533a\u3002 class VertexBuffer { public: virtual ~VertexBuffer() {} virtual void Bind() const = 0; virtual void Unbind() const = 0; static VertexBuffer* Create(float* vertices, uint32_t size); }; \u4ece VBO \u4e2d\u53d6\u6570\u9700\u8981\u6839\u636e\u5185\u90e8\u5b58\u50a8\u7684\u6570\u636e\u7c7b\u578b\uff0c\u8ba1\u7b97\u6570\u636e\u8d77\u59cb\u5730\u5740\u548c\u6570\u636e\u957f\u5ea6\u3002","title":"VBO"},{"location":"Core/Rendering/BasicsOfGameRendering/#bufferelement","text":"BufferElement \uff1a\u50a8\u5b58\u5355\u4f4d\u6570\u636e\u7684\u957f\u5ea6\u7b49\u5176\u4ed6\u5c5e\u6027\u3002 struct BufferElement { std::string Name; ShaderDataType Type; uint32_t Size; uint32_t Offset; bool Normalized; BufferElement() {} BufferElement(ShaderDataType type, const std::string& name, bool normalized = false) : Name(name), Type(type), Size(ShaderDataTypeSize(type)), Offset(0), Normalized(normalized) { } uint32_t GetComponentCount() const { switch (Type) { case ShaderDataType::Float: return 1; case ShaderDataType::Float2: return 2; case ShaderDataType::Float3: return 3; case ShaderDataType::Float4: return 4; case ShaderDataType::Mat3: return 3 * 3; case ShaderDataType::Mat4: return 4 * 4; case ShaderDataType::Int: return 1; case ShaderDataType::Int2: return 2; case ShaderDataType::Int3: return 3; case ShaderDataType::Int4: return 4; case ShaderDataType::Bool: return 1; } HZ_CORE_ASSERT(false, \"Unknown ShaderDataType!\"); return 0; } };","title":"BufferElement"},{"location":"Core/Rendering/BasicsOfGameRendering/#bufferlayout","text":"BufferLayout \uff1a\u8ba1\u7b97\u7f13\u51b2\u533a\u4e2d\u6570\u636e\u7684\u5e03\u5c40\u3002 class BufferLayout { public: BufferLayout() {} BufferLayout(const std::initializer_list<BufferElement>& elements) : m_Elements(elements) { CalculateOffsetsAndStride(); } inline uint32_t GetStride() const { return m_Stride; } inline const std::vector<BufferElement>& GetElements() const { return m_Elements; } std::vector<BufferElement>::iterator begin() { return m_Elements.begin(); } std::vector<BufferElement>::iterator end() { return m_Elements.end(); } std::vector<BufferElement>::const_iterator begin() const { return m_Elements.begin(); } std::vector<BufferElement>::const_iterator end() const { return m_Elements.end(); } private: void CalculateOffsetsAndStride() { uint32_t offset = 0; m_Stride = 0; for (auto& element : m_Elements) { element.Offset = offset; offset += element.Size; m_Stride += element.Size; } } private: std::vector<BufferElement> m_Elements; uint32_t m_Stride = 0; };","title":"BufferLayout"},{"location":"Core/Rendering/BasicsOfGameRendering/#vao","text":"VAO \u662f\u4e00\u4e2a\u5173\u4e8e\u9876\u70b9\u5c5e\u6027\u7684\u6570\u7ec4\uff0c\u6309\u5c5e\u6027\u5bf9\u5e94 VBO \uff08\u544a\u77e5 VBO \u600e\u4e48\u53d6\u6570\u636e\uff09\u3002 class VertexArray { public: virtual ~VertexArray() {} virtual void Bind() const = 0; virtual void Unbind() const = 0; virtual void AddVertexBuffer(const std::shared_ptr<VertexBuffer>& vertexBuffer) = 0; virtual void SetIndexBuffer(const std::shared_ptr<IndexBuffer>& indexBuffer) = 0; virtual const std::vector<std::shared_ptr<VertexBuffer>>& GetVertexBuffers() const = 0; virtual const std::shared_ptr<IndexBuffer>& GetIndexBuffer() const = 0; static VertexArray* Create(); };","title":"VAO"},{"location":"Core/Rendering/BasicsOfGameRendering/#ibo","text":"IBO \u662f\u4e00\u4e2a\u5b58\u653e\u56fe\u5143\u9876\u70b9\u5728\u9876\u70b9\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15\u7684\u7f13\u51b2\u533a\u3002 class IndexBuffer { public: virtual ~IndexBuffer() {} virtual void Bind() const = 0; virtual void Unbind() const = 0; virtual uint32_t GetCount() const = 0; static IndexBuffer* Create(uint32_t* indices, uint32_t size); };","title":"IBO"},{"location":"Core/Rendering/BasicsOfGameRendering/#texture","text":"Texture \u7684\u672c\u8d28\u5c31\u662f\u4e00\u4e2a\u6570\u636e\u7f13\u51b2\u533a\uff0c\u53ea\u9700\u8981\u628a\u76f8\u5e94\u7684\u6570\u636e\u5b58\u50a8\u5728\u76f8\u5e94\u7684\u4f4d\u7f6e\uff0c\u4fbf\u53ef\u5c06\u503c\u4f20\u7ed9\u76f8\u5e94\u7684\u9876\u70b9\u3002 class Texture { public: virtual ~Texture() = default; virtual uint32_t GetWidth() const = 0; virtual uint32_t GetHeight() const = 0; virtual void Bind(uint32_t slot = 0) const = 0; };","title":"Texture"},{"location":"Core/Rendering/BasicsOfGameRendering/#framebuffer","text":"\u5176\u672c\u8d28\u662f\u4e00\u5757 buffer \u533a\uff0c\u7528\u4e8e\u5b58\u50a8\u67d0\u4e00\u5e27\u6240\u6709\u7684 buffer \u6570\u636e\u3002 class Framebuffer { public: virtual void Bind() = 0; virtual void Unbind() = 0; virtual uint32_t GetColorAttachmentRendererID() const = 0; virtual const FramebufferSpecification& GetSpecification() const = 0; static Ref<Framebuffer> Create(const FramebufferSpecification& spec); };","title":"Framebuffer"},{"location":"Core/Rendering/BasicsOfGameRendering/#platform-agnostic","text":"","title":"Platform agnostic"},{"location":"Core/Rendering/BasicsOfGameRendering/#renderer","text":"\u5305\u88c5\u6e32\u67d3\u7684\u57fa\u7840\u547d\u4ee4\uff08\u5bf9\u4e8e CPU \uff09\u3002 class Renderer { public: static void BeginScene(); static void EndScene(); static void Submit(const std::shared_ptr<VertexArray>& vertexArray); inline static RendererAPI::API GetAPI() { return RendererAPI::GetAPI(); } }; \u5176\u4e2d\uff0c BeginScene \u8d1f\u8d23\u6e32\u67d3\u524d\u7684\u73af\u5883\u8bbe\u7f6e\uff1b Submit \u4f1a\u6536\u96c6\u6e32\u67d3\u6307\u4ee4\uff0c\u5b58\u5165\u547d\u4ee4\u961f\u5217\u4e2d\uff1b EndScene \u8868\u793a\u6307\u4ee4\u6536\u96c6\u7ed3\u675f\uff0c\u5f00\u59cb\u6e32\u67d3\u3002","title":"Renderer"},{"location":"Core/Rendering/BasicsOfGameRendering/#rendercommand","text":"\u5305\u88c5\u6e32\u67d3\u7684\u57fa\u7840\u547d\u4ee4\uff08\u5bf9\u4e8e GPU \uff09\u3002 class RenderCommand { public: inline static void SetClearColor(const glm::vec4& color) { s_RendererAPI->SetClearColor(color); } inline static void Clear() { s_RendererAPI->Clear(); } inline static void DrawIndexed(const std::shared_ptr<VertexArray>& vertexArray) { s_RendererAPI->DrawIndexed(vertexArray); } private: static RendererAPI* s_RendererAPI; }; \u5b9e\u9645\u8fd0\u884c\u4e2d\u8fd9\u4e9b\u6e32\u67d3\u547d\u4ee4\u4f1a\u88ab\u5b58\u5165\u4e00\u4e2a\u961f\u5217\uff0c\u4ece\u800c\u4e0d\u65ad\u5730\u5411 GPU \u53d1\u9001\u6307\u4ee4\u3002","title":"RenderCommand"},{"location":"Core/Rendering/BasicsOfGameRendering/#camera","text":"","title":"Camera"},{"location":"Core/Rendering/BasicsOfGameRendering/#orthographiccamera","text":"\u5bf9\u4e8e\u6b63\u4ea4\u76f8\u673a\uff0c\u6211\u4eec\u9700\u8981\u6839\u636e\u5176 FOV \u7b49\u6570\u636e\u8ba1\u7b97\u57fa\u4e8e\u6b64\u76f8\u673a\u7684\u89c6\u89d2\u77e9\u9635\u548c\u6295\u5f71\u77e9\u9635\uff0c\u518d\u7b49\u8fd9\u4e9b\u6570\u636e\u4f20\u5165 Shader \u4e2d\uff0c\u4ece\u800c\u5bf9\u56fe\u5f62\u8fdb\u884c\u5750\u6807\u53d8\u6362\u3002 class OrthographicCamera { public: OrthographicCamera(float left, float right, float bottom, float top); const glm::vec3& GetPosition() const { return m_Position; } void SetPosition(const glm::vec3& position) { m_Position = position; RecalculateViewMatrix(); } float GetRotation() const { return m_Rotation; } void SetRotation(float rotation) { m_Rotation = rotation; RecalculateViewMatrix(); } const glm::mat4& GetProjectionMatrix() const { return m_ProjectionMatrix; } const glm::mat4& GetViewMatrix() const { return m_ViewMatrix; } const glm::mat4& GetViewProjectionMatrix() const { return m_ViewProjectionMatrix; } private: void RecalculateViewMatrix(); private: glm::mat4 m_ProjectionMatrix; glm::mat4 m_ViewMatrix; glm::mat4 m_ViewProjectionMatrix; glm::vec3 m_Position = { 0.0f, 0.0f, 0.0f }; float m_Rotation = 0.0f; };","title":"OrthographicCamera"},{"location":"Core/Rendering/BasicsOfGameRendering/#_4","text":"","title":"\u53ef\u89c1\u6027\u88c1\u526a"},{"location":"Core/Rendering/BasicsOfGameRendering/#bvh-culling","text":"BVH Culling \u5c06\u6574\u4e2a\u7a7a\u95f4\u4e0d\u65ad\u7ec6\u5206\u6210\u4e86\u4e0d\u540c\u5927\u5c0f\u7684\u5b50\u5305\u56f4\u76d2\uff0c\u5e76\u7528\u6811\u53bb\u7ba1\u7406\u3002 BVH \u7b97\u6cd5\u5728\u5de5\u4e1a\u754c\u5e7f\u6cdb\u4f7f\u7528\uff0c\u56e0\u4e3a\u73b0\u4ee3\u6e38\u620f\u573a\u666f\u5185\u52a8\u7684\u7269\u4f53\u6bd4\u8f83\u591a\uff0c\u56e0\u6b64\u5f53\u8282\u70b9\u53d8\u52a8\u540e\uff0c\u9700\u8981\u91cd\u65b0\u6784\u5efa\u6811\u72b6\u7ed3\u6784\uff0c\u6b64\u65f6\u8981\u8003\u8651\u91cd\u65b0\u6784\u5efa\u7684\u6210\u672c\u4e00\u5b9a\u8981\u5f88\u4f4e\uff0c\u800c BVH \u6070\u597d\u5728\u6b64\u6709\u5f88\u591a\u4f18\u52bf\uff0c\u56e0\u6b64 BVH \u9002\u7528\u4e8e\u5f00\u9614\u52a8\u6001\u573a\u666f\u3002","title":"BVH Culling"},{"location":"Core/Rendering/BasicsOfGameRendering/#early-z","text":"\u6bd4\u5f53\u524d\u5149\u6805\u4e0a\u6e32\u67d3\u7684\u56fe\u5143\u6df1\u5ea6\u66f4\u6df1\u7684\u56fe\u5143\u5c06\u4f1a\u88ab\u4e22\u5f03\u3002","title":"Early-Z"},{"location":"Core/Rendering/BasicsOfGameRendering/#_5","text":"\u4e3a\u4e86\u6ee1\u8db3\u968f\u673a\u8bbf\u95ee\u56fe\u7247\u50cf\u7d20\u7684\u9700\u6c42\uff0c\u6e38\u620f\u5f15\u64ce\u4e2d\u4e00\u822c\u4f7f\u7528 Block \u7684\u601d\u60f3\uff0c\u800c\u4e0d\u662f\u7528\u4f20\u7edf\u7684\u56fe\u7247\u538b\u7f29\u7b97\u6cd5\u3002","title":"\u7eb9\u7406\u538b\u7f29"},{"location":"Core/Rendering/BasicsOfGameRendering/#block-compression","text":"\u4ee5 DXTC \u683c\u5f0f\u4e3e\u4f8b\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5212\u5206\u7684\u5c0f\u5757\uff0c\u53d6\u5f97\u5176\u4e2d\u6700\u4eae\u548c\u6700\u6697\u7684\u50cf\u7d20\u70b9\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u901a\u8fc7\u63d2\u503c\u5904\u7406\u4ece\u800c\u6c42\u5f97\u4e8c\u8005\u4e2d\u95f4\u4e00\u7cfb\u5217\u7684\u989c\u8272\u3002","title":"Block Compression"},{"location":"Core/Rendering/BasicsOfGameRendering/#_6","text":"","title":"\u5efa\u6a21"},{"location":"Core/Rendering/BasicsOfGameRendering/#_7","text":"","title":"\u591a\u8fb9\u5f62\u5efa\u6a21"},{"location":"Core/Rendering/BasicsOfGameRendering/#_8","text":"","title":"\u96d5\u523b"},{"location":"Core/Rendering/BasicsOfGameRendering/#_9","text":"","title":"\u5b9e\u4f53\u626b\u63cf"},{"location":"Core/Rendering/BasicsOfGameRendering/#_10","text":"","title":"\u7a0b\u5e8f\u5316\u5efa\u6a21"},{"location":"Core/Rendering/BasicsOfGameRendering/#_11","text":"","title":"\u6bd4\u8f83"},{"location":"Core/Rendering/BasicsOfGameRendering/#_12","text":"\u6838\u5fc3\u601d\u60f3\u662f\u5c06\u6a21\u578b\u5206\u6210\u591a\u4e2a Cluster \uff0c\u6839\u636e\u8fd9\u4e9b Cluster \u4e0e\u6444\u50cf\u673a\u7684\u8fdc\u8fd1\u6765\u5c55\u793a\u4e0d\u540c\u7684\u7ec6\u8282\u3002 \u8fd9\u8981\u5904\u7406\u7684\u597d\u5904\u5728\u4e8e\u3002 \u73b0\u4ee3 GPU \u5df2\u7ecf\u53ef\u4ee5\u57fa\u4e8e\u6570\u636e\uff0c\u52a8\u6001\u751f\u6210\u51e0\u4f55\u7ec6\u8282\uff0c\u800c\u4e0d\u662f\u50cf\u539f\u5148\u7684\u7ba1\u7ebf\u5c06 mesh \u6570\u636e\u4e0a\u4f20\uff1b \u5f53\u4f60\u5c06\u6bcf\u4e2a cluster \u5927\u5c0f\u786e\u5b9a\u597d\u540e\uff0c\u7531\u4e8e\u5b83\u7684\u8ba1\u7b97\u90fd\u662f\u9ad8\u6548\u4e00\u81f4\u7684\uff0c\u4ee5\u76f8\u540c\u7684 Cluster \u7ed3\u6784\u8ba9 GPU \u6765\u5e76\u884c\u5904\u7406\u65f6\uff0c\u63d0\u9ad8\u4e86\u6548\u7387\uff1b \u53ef\u4ee5\u5bf9\u6a21\u578b\u8fdb\u884c Cluster \u5254\u9664\u3002","title":"\u65b0\u7684\u6a21\u578b\u7ba1\u7ebf"},{"location":"Core/Rendering/BasicsOfGameRendering/#_13","text":"BVH Culling \u3002 Block Compression \u3002 \u65b0\u7684\u6a21\u578b\u7ba1\u7ebf\u3002","title":"\u8d44\u6599\u6765\u6e90"},{"location":"Core/Rendering/SpecialRendering/","text":"","title":"SpecialRendering"},{"location":"Function/ImGuiLayer/","text":"\u6784\u5efa ImGuiLayer \uff1a\u7ee7\u627f\u81ea Layer \u3002 class HAZEL_API ImGuiLayer : public Layer { public: ImGuiLayer(); ~ImGuiLayer(); void OnAttach(); void OnDetach(); void OnUpdate(); void OnEvent(Event& event); private: float m_Time = 0.0f; }; \u4f7f\u7528 \u53ea\u9700\u5728\u7f16\u8f91\u5668\u4e2d\u6dfb\u52a0\u5982\u4e0b\u4ee3\u7801\uff0c\u5c31\u53ef\u4ee5\u7ed8\u5236\u51fa\u4e00\u4e2a\u5c0f\u7a97\uff08 Test \uff09\u3002 ImGui::Begin(\"Test\"); ImGui::Text(\"Hello World\"); ImGui::End();","title":"ImGui \u5c42"},{"location":"Function/ImGuiLayer/#_1","text":"ImGuiLayer \uff1a\u7ee7\u627f\u81ea Layer \u3002 class HAZEL_API ImGuiLayer : public Layer { public: ImGuiLayer(); ~ImGuiLayer(); void OnAttach(); void OnDetach(); void OnUpdate(); void OnEvent(Event& event); private: float m_Time = 0.0f; };","title":"\u6784\u5efa"},{"location":"Function/ImGuiLayer/#_2","text":"\u53ea\u9700\u5728\u7f16\u8f91\u5668\u4e2d\u6dfb\u52a0\u5982\u4e0b\u4ee3\u7801\uff0c\u5c31\u53ef\u4ee5\u7ed8\u5236\u51fa\u4e00\u4e2a\u5c0f\u7a97\uff08 Test \uff09\u3002 ImGui::Begin(\"Test\"); ImGui::Text(\"Hello World\"); ImGui::End();","title":"\u4f7f\u7528"},{"location":"Function/Scene/","text":"\u7ed3\u6784 Scene \u5c31\u662f\u8fd9\u5f20\u56fe\u4e2d\u7684 World \uff0c\u7528\u4e8e\u5b58\u653e\u573a\u666f\u4e2d\u6240\u6709\u7684 Entity \u4ee5\u53ca\u66f4\u65b0\u573a\u666f\u4e2d\u7684 System \u3002 Scene class Scene { public: Scene(); ~Scene(); Entity CreateEntity(const std::string& name = std::string()); void DestroyEntity(Entity entity); void OnUpdate(Timestep ts); void OnViewportResize(uint32_t width, uint32_t height); private: template<typename T> void OnComponentAdded(Entity entity, T& component); private: entt::registry m_Registry; uint32_t m_ViewportWidth = 0, m_ViewportHeight = 0; friend class Entity; friend class SceneSerializer; friend class SceneHierarchyPanel; }; \u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316 \u5bf9\u4e8e Scene \u6765\u8bf4\u6700\u91cd\u8981\u7684\u5c31\u662f\u5b58\u50a8\u548c\u8bfb\u53d6\u529f\u80fd\u3002 class SceneSerializer { public: SceneSerializer(const Ref<Scene>& scene); void Serialize(const std::string& filepath); void SerializeRuntime(const std::string& filepath); bool Deserialize(const std::string& filepath); bool DeserializeRuntime(const std::string& filepath); private: Ref<Scene> m_Scene; }; \u8fd9\u91cc\u901a\u8fc7 YAML \u5b9e\u73b0\u5c06\u573a\u666f\u5b58\u5165\u6587\u672c\u6587\u4ef6\u3002 \u5b9a\u4e49 YAML \u63a5\u53e3\u3002 namespace YAML { template<> struct convert<glm::vec3> { static Node encode(const glm::vec3& rhs) { Node node; node.push_back(rhs.x); node.push_back(rhs.y); node.push_back(rhs.z); return node; } static bool decode(const Node& node, glm::vec3& rhs) { if (!node.IsSequence() || node.size() != 3) return false; rhs.x = node[0].as<float>(); rhs.y = node[1].as<float>(); rhs.z = node[2].as<float>(); return true; } }; template<> struct convert<glm::vec4> { static Node encode(const glm::vec4& rhs) { Node node; node.push_back(rhs.x); node.push_back(rhs.y); node.push_back(rhs.z); node.push_back(rhs.w); return node; } static bool decode(const Node& node, glm::vec4& rhs) { if (!node.IsSequence() || node.size() != 4) return false; rhs.x = node[0].as<float>(); rhs.y = node[1].as<float>(); rhs.z = node[2].as<float>(); rhs.w = node[3].as<float>(); return true; } }; } \u8c03\u7528 YAML \u63a5\u53e3\u5e8f\u5217\u5316\u548c\u53cd\u5411\u5e8f\u5217\u5316\u573a\u666f\u3002 namespace Hazel { YAML::Emitter& operator<<(YAML::Emitter& out, const glm::vec3& v) { out << YAML::Flow; out << YAML::BeginSeq << v.x << v.y << v.z << YAML::EndSeq; return out; } YAML::Emitter& operator<<(YAML::Emitter& out, const glm::vec4& v) { out << YAML::Flow; out << YAML::BeginSeq << v.x << v.y << v.z << v.w << YAML::EndSeq; return out; } SceneSerializer::SceneSerializer(const Ref<Scene>& scene) : m_Scene(scene) { } static void SerializeEntity(YAML::Emitter& out, Entity entity) { out << YAML::BeginMap; // Entity out << YAML::Key << \"Entity\" << YAML::Value << \"12837192831273\"; // TODO: Entity ID goes here if (entity.HasComponent<TagComponent>()) { out << YAML::Key << \"TagComponent\"; out << YAML::BeginMap; // TagComponent auto& tag = entity.GetComponent<TagComponent>().Tag; out << YAML::Key << \"Tag\" << YAML::Value << tag; out << YAML::EndMap; // TagComponent } if (entity.HasComponent<TransformComponent>()) { out << YAML::Key << \"TransformComponent\"; out << YAML::BeginMap; // TransformComponent auto& tc = entity.GetComponent<TransformComponent>(); out << YAML::Key << \"Translation\" << YAML::Value << tc.Translation; out << YAML::Key << \"Rotation\" << YAML::Value << tc.Rotation; out << YAML::Key << \"Scale\" << YAML::Value << tc.Scale; out << YAML::EndMap; // TransformComponent } if (entity.HasComponent<CameraComponent>()) { out << YAML::Key << \"CameraComponent\"; out << YAML::BeginMap; // CameraComponent auto& cameraComponent = entity.GetComponent<CameraComponent>(); auto& camera = cameraComponent.Camera; out << YAML::Key << \"Camera\" << YAML::Value; out << YAML::BeginMap; // Camera out << YAML::Key << \"ProjectionType\" << YAML::Value << (int)camera.GetProjectionType(); out << YAML::Key << \"PerspectiveFOV\" << YAML::Value << camera.GetPerspectiveVerticalFOV(); out << YAML::Key << \"PerspectiveNear\" << YAML::Value << camera.GetPerspectiveNearClip(); out << YAML::Key << \"PerspectiveFar\" << YAML::Value << camera.GetPerspectiveFarClip(); out << YAML::Key << \"OrthographicSize\" << YAML::Value << camera.GetOrthographicSize(); out << YAML::Key << \"OrthographicNear\" << YAML::Value << camera.GetOrthographicNearClip(); out << YAML::Key << \"OrthographicFar\" << YAML::Value << camera.GetOrthographicFarClip(); out << YAML::EndMap; // Camera out << YAML::Key << \"Primary\" << YAML::Value << cameraComponent.Primary; out << YAML::Key << \"FixedAspectRatio\" << YAML::Value << cameraComponent.FixedAspectRatio; out << YAML::EndMap; // CameraComponent } if (entity.HasComponent<SpriteRendererComponent>()) { out << YAML::Key << \"SpriteRendererComponent\"; out << YAML::BeginMap; // SpriteRendererComponent auto& spriteRendererComponent = entity.GetComponent<SpriteRendererComponent>(); out << YAML::Key << \"Color\" << YAML::Value << spriteRendererComponent.Color; out << YAML::EndMap; // SpriteRendererComponent } out << YAML::EndMap; // Entity } void SceneSerializer::Serialize(const std::string& filepath) { YAML::Emitter out; out << YAML::BeginMap; out << YAML::Key << \"Scene\" << YAML::Value << \"Untitled\"; out << YAML::Key << \"Entities\" << YAML::Value << YAML::BeginSeq; m_Scene->m_Registry.each([&](auto entityID) { Entity entity = { entityID, m_Scene.get() }; if (!entity) return; SerializeEntity(out, entity); }); out << YAML::EndSeq; out << YAML::EndMap; std::ofstream fout(filepath); fout << out.c_str(); } void SceneSerializer::SerializeRuntime(const std::string& filepath) { // Not implemented HZ_CORE_ASSERT(false); } bool SceneSerializer::Deserialize(const std::string& filepath) { std::ifstream stream(filepath); std::stringstream strStream; strStream << stream.rdbuf(); YAML::Node data = YAML::Load(strStream.str()); if (!data[\"Scene\"]) return false; std::string sceneName = data[\"Scene\"].as<std::string>(); HZ_CORE_TRACE(\"Deserializing scene '{0}'\", sceneName); auto entities = data[\"Entities\"]; if (entities) { for (auto entity : entities) { uint64_t uuid = entity[\"Entity\"].as<uint64_t>(); // TODO std::string name; auto tagComponent = entity[\"TagComponent\"]; if (tagComponent) name = tagComponent[\"Tag\"].as<std::string>(); HZ_CORE_TRACE(\"Deserialized entity with ID = {0}, name = {1}\", uuid, name); Entity deserializedEntity = m_Scene->CreateEntity(name); auto transformComponent = entity[\"TransformComponent\"]; if (transformComponent) { // Entities always have transforms auto& tc = deserializedEntity.GetComponent<TransformComponent>(); tc.Translation = transformComponent[\"Translation\"].as<glm::vec3>(); tc.Rotation = transformComponent[\"Rotation\"].as<glm::vec3>(); tc.Scale = transformComponent[\"Scale\"].as<glm::vec3>(); } auto cameraComponent = entity[\"CameraComponent\"]; if (cameraComponent) { auto& cc = deserializedEntity.AddComponent<CameraComponent>(); auto& cameraProps = cameraComponent[\"Camera\"]; cc.Camera.SetProjectionType((SceneCamera::ProjectionType)cameraProps[\"ProjectionType\"].as<int>()); cc.Camera.SetPerspectiveVerticalFOV(cameraProps[\"PerspectiveFOV\"].as<float>()); cc.Camera.SetPerspectiveNearClip(cameraProps[\"PerspectiveNear\"].as<float>()); cc.Camera.SetPerspectiveFarClip(cameraProps[\"PerspectiveFar\"].as<float>()); cc.Camera.SetOrthographicSize(cameraProps[\"OrthographicSize\"].as<float>()); cc.Camera.SetOrthographicNearClip(cameraProps[\"OrthographicNear\"].as<float>()); cc.Camera.SetOrthographicFarClip(cameraProps[\"OrthographicFar\"].as<float>()); cc.Primary = cameraComponent[\"Primary\"].as<bool>(); cc.FixedAspectRatio = cameraComponent[\"FixedAspectRatio\"].as<bool>(); } auto spriteRendererComponent = entity[\"SpriteRendererComponent\"]; if (spriteRendererComponent) { auto& src = deserializedEntity.AddComponent<SpriteRendererComponent>(); src.Color = spriteRendererComponent[\"Color\"].as<glm::vec4>(); } } } return true; } bool SceneSerializer::DeserializeRuntime(const std::string& filepath) { // Not implemented HZ_CORE_ASSERT(false); return false; } }","title":"Scene"},{"location":"Function/Scene/#_1","text":"Scene \u5c31\u662f\u8fd9\u5f20\u56fe\u4e2d\u7684 World \uff0c\u7528\u4e8e\u5b58\u653e\u573a\u666f\u4e2d\u6240\u6709\u7684 Entity \u4ee5\u53ca\u66f4\u65b0\u573a\u666f\u4e2d\u7684 System \u3002","title":"\u7ed3\u6784"},{"location":"Function/Scene/#scene","text":"class Scene { public: Scene(); ~Scene(); Entity CreateEntity(const std::string& name = std::string()); void DestroyEntity(Entity entity); void OnUpdate(Timestep ts); void OnViewportResize(uint32_t width, uint32_t height); private: template<typename T> void OnComponentAdded(Entity entity, T& component); private: entt::registry m_Registry; uint32_t m_ViewportWidth = 0, m_ViewportHeight = 0; friend class Entity; friend class SceneSerializer; friend class SceneHierarchyPanel; };","title":"Scene"},{"location":"Function/Scene/#_2","text":"\u5bf9\u4e8e Scene \u6765\u8bf4\u6700\u91cd\u8981\u7684\u5c31\u662f\u5b58\u50a8\u548c\u8bfb\u53d6\u529f\u80fd\u3002 class SceneSerializer { public: SceneSerializer(const Ref<Scene>& scene); void Serialize(const std::string& filepath); void SerializeRuntime(const std::string& filepath); bool Deserialize(const std::string& filepath); bool DeserializeRuntime(const std::string& filepath); private: Ref<Scene> m_Scene; }; \u8fd9\u91cc\u901a\u8fc7 YAML \u5b9e\u73b0\u5c06\u573a\u666f\u5b58\u5165\u6587\u672c\u6587\u4ef6\u3002 \u5b9a\u4e49 YAML \u63a5\u53e3\u3002 namespace YAML { template<> struct convert<glm::vec3> { static Node encode(const glm::vec3& rhs) { Node node; node.push_back(rhs.x); node.push_back(rhs.y); node.push_back(rhs.z); return node; } static bool decode(const Node& node, glm::vec3& rhs) { if (!node.IsSequence() || node.size() != 3) return false; rhs.x = node[0].as<float>(); rhs.y = node[1].as<float>(); rhs.z = node[2].as<float>(); return true; } }; template<> struct convert<glm::vec4> { static Node encode(const glm::vec4& rhs) { Node node; node.push_back(rhs.x); node.push_back(rhs.y); node.push_back(rhs.z); node.push_back(rhs.w); return node; } static bool decode(const Node& node, glm::vec4& rhs) { if (!node.IsSequence() || node.size() != 4) return false; rhs.x = node[0].as<float>(); rhs.y = node[1].as<float>(); rhs.z = node[2].as<float>(); rhs.w = node[3].as<float>(); return true; } }; } \u8c03\u7528 YAML \u63a5\u53e3\u5e8f\u5217\u5316\u548c\u53cd\u5411\u5e8f\u5217\u5316\u573a\u666f\u3002 namespace Hazel { YAML::Emitter& operator<<(YAML::Emitter& out, const glm::vec3& v) { out << YAML::Flow; out << YAML::BeginSeq << v.x << v.y << v.z << YAML::EndSeq; return out; } YAML::Emitter& operator<<(YAML::Emitter& out, const glm::vec4& v) { out << YAML::Flow; out << YAML::BeginSeq << v.x << v.y << v.z << v.w << YAML::EndSeq; return out; } SceneSerializer::SceneSerializer(const Ref<Scene>& scene) : m_Scene(scene) { } static void SerializeEntity(YAML::Emitter& out, Entity entity) { out << YAML::BeginMap; // Entity out << YAML::Key << \"Entity\" << YAML::Value << \"12837192831273\"; // TODO: Entity ID goes here if (entity.HasComponent<TagComponent>()) { out << YAML::Key << \"TagComponent\"; out << YAML::BeginMap; // TagComponent auto& tag = entity.GetComponent<TagComponent>().Tag; out << YAML::Key << \"Tag\" << YAML::Value << tag; out << YAML::EndMap; // TagComponent } if (entity.HasComponent<TransformComponent>()) { out << YAML::Key << \"TransformComponent\"; out << YAML::BeginMap; // TransformComponent auto& tc = entity.GetComponent<TransformComponent>(); out << YAML::Key << \"Translation\" << YAML::Value << tc.Translation; out << YAML::Key << \"Rotation\" << YAML::Value << tc.Rotation; out << YAML::Key << \"Scale\" << YAML::Value << tc.Scale; out << YAML::EndMap; // TransformComponent } if (entity.HasComponent<CameraComponent>()) { out << YAML::Key << \"CameraComponent\"; out << YAML::BeginMap; // CameraComponent auto& cameraComponent = entity.GetComponent<CameraComponent>(); auto& camera = cameraComponent.Camera; out << YAML::Key << \"Camera\" << YAML::Value; out << YAML::BeginMap; // Camera out << YAML::Key << \"ProjectionType\" << YAML::Value << (int)camera.GetProjectionType(); out << YAML::Key << \"PerspectiveFOV\" << YAML::Value << camera.GetPerspectiveVerticalFOV(); out << YAML::Key << \"PerspectiveNear\" << YAML::Value << camera.GetPerspectiveNearClip(); out << YAML::Key << \"PerspectiveFar\" << YAML::Value << camera.GetPerspectiveFarClip(); out << YAML::Key << \"OrthographicSize\" << YAML::Value << camera.GetOrthographicSize(); out << YAML::Key << \"OrthographicNear\" << YAML::Value << camera.GetOrthographicNearClip(); out << YAML::Key << \"OrthographicFar\" << YAML::Value << camera.GetOrthographicFarClip(); out << YAML::EndMap; // Camera out << YAML::Key << \"Primary\" << YAML::Value << cameraComponent.Primary; out << YAML::Key << \"FixedAspectRatio\" << YAML::Value << cameraComponent.FixedAspectRatio; out << YAML::EndMap; // CameraComponent } if (entity.HasComponent<SpriteRendererComponent>()) { out << YAML::Key << \"SpriteRendererComponent\"; out << YAML::BeginMap; // SpriteRendererComponent auto& spriteRendererComponent = entity.GetComponent<SpriteRendererComponent>(); out << YAML::Key << \"Color\" << YAML::Value << spriteRendererComponent.Color; out << YAML::EndMap; // SpriteRendererComponent } out << YAML::EndMap; // Entity } void SceneSerializer::Serialize(const std::string& filepath) { YAML::Emitter out; out << YAML::BeginMap; out << YAML::Key << \"Scene\" << YAML::Value << \"Untitled\"; out << YAML::Key << \"Entities\" << YAML::Value << YAML::BeginSeq; m_Scene->m_Registry.each([&](auto entityID) { Entity entity = { entityID, m_Scene.get() }; if (!entity) return; SerializeEntity(out, entity); }); out << YAML::EndSeq; out << YAML::EndMap; std::ofstream fout(filepath); fout << out.c_str(); } void SceneSerializer::SerializeRuntime(const std::string& filepath) { // Not implemented HZ_CORE_ASSERT(false); } bool SceneSerializer::Deserialize(const std::string& filepath) { std::ifstream stream(filepath); std::stringstream strStream; strStream << stream.rdbuf(); YAML::Node data = YAML::Load(strStream.str()); if (!data[\"Scene\"]) return false; std::string sceneName = data[\"Scene\"].as<std::string>(); HZ_CORE_TRACE(\"Deserializing scene '{0}'\", sceneName); auto entities = data[\"Entities\"]; if (entities) { for (auto entity : entities) { uint64_t uuid = entity[\"Entity\"].as<uint64_t>(); // TODO std::string name; auto tagComponent = entity[\"TagComponent\"]; if (tagComponent) name = tagComponent[\"Tag\"].as<std::string>(); HZ_CORE_TRACE(\"Deserialized entity with ID = {0}, name = {1}\", uuid, name); Entity deserializedEntity = m_Scene->CreateEntity(name); auto transformComponent = entity[\"TransformComponent\"]; if (transformComponent) { // Entities always have transforms auto& tc = deserializedEntity.GetComponent<TransformComponent>(); tc.Translation = transformComponent[\"Translation\"].as<glm::vec3>(); tc.Rotation = transformComponent[\"Rotation\"].as<glm::vec3>(); tc.Scale = transformComponent[\"Scale\"].as<glm::vec3>(); } auto cameraComponent = entity[\"CameraComponent\"]; if (cameraComponent) { auto& cc = deserializedEntity.AddComponent<CameraComponent>(); auto& cameraProps = cameraComponent[\"Camera\"]; cc.Camera.SetProjectionType((SceneCamera::ProjectionType)cameraProps[\"ProjectionType\"].as<int>()); cc.Camera.SetPerspectiveVerticalFOV(cameraProps[\"PerspectiveFOV\"].as<float>()); cc.Camera.SetPerspectiveNearClip(cameraProps[\"PerspectiveNear\"].as<float>()); cc.Camera.SetPerspectiveFarClip(cameraProps[\"PerspectiveFar\"].as<float>()); cc.Camera.SetOrthographicSize(cameraProps[\"OrthographicSize\"].as<float>()); cc.Camera.SetOrthographicNearClip(cameraProps[\"OrthographicNear\"].as<float>()); cc.Camera.SetOrthographicFarClip(cameraProps[\"OrthographicFar\"].as<float>()); cc.Primary = cameraComponent[\"Primary\"].as<bool>(); cc.FixedAspectRatio = cameraComponent[\"FixedAspectRatio\"].as<bool>(); } auto spriteRendererComponent = entity[\"SpriteRendererComponent\"]; if (spriteRendererComponent) { auto& src = deserializedEntity.AddComponent<SpriteRendererComponent>(); src.Color = spriteRendererComponent[\"Color\"].as<glm::vec4>(); } } } return true; } bool SceneSerializer::DeserializeRuntime(const std::string& filepath) { // Not implemented HZ_CORE_ASSERT(false); return false; } }","title":"\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316"},{"location":"Function/Gameplay/GameplayBasics/","text":"\u4e8b\u4ef6\u673a\u5236 \u5b9e\u73b0\u4e8b\u4ef6\u673a\u5236\u9700\u8981\u4ee5\u4e0b\u4e09\u4e2a\u529f\u80fd\u6a21\u5757\u3002 Event Definition \u5b9a\u4e49\u4e8b\u4ef6\u7684\u7c7b\u578b\u3002 Callback Registration \u4e8b\u4ef6\u6fc0\u6d3b\u56de\u8c03\u51fd\u6570\u3002 \u4e3a\u4e86\u9632\u6b62\u62e5\u6709\u56de\u8c03\u51fd\u6570\u7684\u5bf9\u8c61\u88ab\u5220\u9664\u5bfc\u81f4\u4e8b\u4ef6\u6fc0\u6d3b\u4e86\u91ce\u6307\u9488\uff0c\u51fa\u73b0\u4e86\u5bf9\u8c61\u5f3a\u5f15\u7528\u548c\u5bf9\u8c61\u5f31\u5f15\u7528\u3002 Object Strong Reference \u5982\u679c\u5bf9\u8c61 A \u7684\u751f\u547d\u5468\u671f\u5185\u53ef\u4ee5\u6fc0\u6d3b\u5bf9\u8c61 B \u7684\u56de\u8c03\u51fd\u6570\uff0c\u90a3\u4e48 B \u4e00\u5b9a\u8981\u540e\u4e8e A \u88ab\u9500\u6bc1\uff08\u5185\u5b58\u9501\u5b9a\uff09\u3002 Object Weak Reference \u5728\u6fc0\u6d3b\u524d\u5224\u65ad\u5bf9\u8c61\u662f\u5426\u5df2\u88ab\u9500\u6bc1\u3002 Event Despatching Event Despatching : Immediate \u76f4\u63a5\u6d3e\u53d1\u6d88\u606f\u4f1a\u5bfc\u81f4\u6d88\u606f\u7b49\u5f85\uff0c\u540c\u65f6\u4f1a\u4eba\u4e3a\u7684\u9020\u6210\u6d88\u606f\u95f4\u7684\u5173\u8054\uff0c\u5bfc\u81f4\u5e76\u53d1\u6027\u964d\u4f4e\u3002 Event Despatching : Queue \u5c06\u4e00\u5e27\u7684\u4e8b\u4ef6\u50a8\u5b58\u8d77\u6765\uff0c\u5728\u4e0b\u4e00\u5e27\u6765\u4e34\u524d\u5b8c\u6210\u5904\u7406\u3002 \u4f18\u5316 \u53ef\u4ee5\u901a\u8fc7\u73af\u5f62\u961f\u5217\u63a7\u5236\u6d88\u606f\u5360\u7528\u7684\u5185\u5b58\u7a7a\u95f4\u3002 \u5bf9\u6d88\u606f\u5206\u7c7b\u5904\u7406\u3002 \u95ee\u9898 \u4e0d\u80fd\u4fdd\u8bc1\u6d88\u606f\u6267\u884c\u987a\u5e8f\u3002 \u6709\u4e00\u5e27\u7684\u5ef6\u8fdf\u3002 \u811a\u672c\u7cfb\u7edf \u5f15\u64ce\u8c03\u7528\u811a\u672c \u7c7b\u4f3c\u4e8e Unity \uff0c\u901a\u8fc7\u811a\u672c\u6269\u5145 Component \u529f\u80fd\u3002 \u811a\u672c\u8c03\u7528\u5f15\u64ce \u5c06\u5f15\u64ce\u89c6\u4e3a SDK \uff0c\u66b4\u9732\u63a5\u53e3\u4f9b\u811a\u672c\u8c03\u7528\u3002 \u53ef\u89c6\u5316\u811a\u672c \u5e76\u4e0d\u60f3\u63d0\u592a\u591a\u53ef\u89c6\u5316\u811a\u672c\u7684\u4e8b\u60c5\uff0c\u6d89\u53ca\u5230\u4e86\u53cd\u5c04\u5b8f\uff08\u7c7b\u4f3c\u4e8e UE \u5c06\u4ee3\u7801\u53cd\u5c04\u5230\u84dd\u56fe\u4e2d\uff09\u3002 3C Character\uff1b Control\uff1b Camera\u3002","title":"\u57fa\u7840"},{"location":"Function/Gameplay/GameplayBasics/#_1","text":"\u5b9e\u73b0\u4e8b\u4ef6\u673a\u5236\u9700\u8981\u4ee5\u4e0b\u4e09\u4e2a\u529f\u80fd\u6a21\u5757\u3002","title":"\u4e8b\u4ef6\u673a\u5236"},{"location":"Function/Gameplay/GameplayBasics/#event-definition","text":"\u5b9a\u4e49\u4e8b\u4ef6\u7684\u7c7b\u578b\u3002","title":"Event Definition"},{"location":"Function/Gameplay/GameplayBasics/#callback-registration","text":"\u4e8b\u4ef6\u6fc0\u6d3b\u56de\u8c03\u51fd\u6570\u3002 \u4e3a\u4e86\u9632\u6b62\u62e5\u6709\u56de\u8c03\u51fd\u6570\u7684\u5bf9\u8c61\u88ab\u5220\u9664\u5bfc\u81f4\u4e8b\u4ef6\u6fc0\u6d3b\u4e86\u91ce\u6307\u9488\uff0c\u51fa\u73b0\u4e86\u5bf9\u8c61\u5f3a\u5f15\u7528\u548c\u5bf9\u8c61\u5f31\u5f15\u7528\u3002","title":"Callback Registration"},{"location":"Function/Gameplay/GameplayBasics/#object-strong-reference","text":"\u5982\u679c\u5bf9\u8c61 A \u7684\u751f\u547d\u5468\u671f\u5185\u53ef\u4ee5\u6fc0\u6d3b\u5bf9\u8c61 B \u7684\u56de\u8c03\u51fd\u6570\uff0c\u90a3\u4e48 B \u4e00\u5b9a\u8981\u540e\u4e8e A \u88ab\u9500\u6bc1\uff08\u5185\u5b58\u9501\u5b9a\uff09\u3002","title":"Object Strong Reference"},{"location":"Function/Gameplay/GameplayBasics/#object-weak-reference","text":"\u5728\u6fc0\u6d3b\u524d\u5224\u65ad\u5bf9\u8c61\u662f\u5426\u5df2\u88ab\u9500\u6bc1\u3002","title":"Object Weak Reference"},{"location":"Function/Gameplay/GameplayBasics/#event-despatching","text":"","title":"Event Despatching"},{"location":"Function/Gameplay/GameplayBasics/#event-despatching-immediate","text":"\u76f4\u63a5\u6d3e\u53d1\u6d88\u606f\u4f1a\u5bfc\u81f4\u6d88\u606f\u7b49\u5f85\uff0c\u540c\u65f6\u4f1a\u4eba\u4e3a\u7684\u9020\u6210\u6d88\u606f\u95f4\u7684\u5173\u8054\uff0c\u5bfc\u81f4\u5e76\u53d1\u6027\u964d\u4f4e\u3002","title":"Event Despatching : Immediate"},{"location":"Function/Gameplay/GameplayBasics/#event-despatching-queue","text":"\u5c06\u4e00\u5e27\u7684\u4e8b\u4ef6\u50a8\u5b58\u8d77\u6765\uff0c\u5728\u4e0b\u4e00\u5e27\u6765\u4e34\u524d\u5b8c\u6210\u5904\u7406\u3002","title":"Event Despatching : Queue"},{"location":"Function/Gameplay/GameplayBasics/#_2","text":"\u53ef\u4ee5\u901a\u8fc7\u73af\u5f62\u961f\u5217\u63a7\u5236\u6d88\u606f\u5360\u7528\u7684\u5185\u5b58\u7a7a\u95f4\u3002 \u5bf9\u6d88\u606f\u5206\u7c7b\u5904\u7406\u3002","title":"\u4f18\u5316"},{"location":"Function/Gameplay/GameplayBasics/#_3","text":"\u4e0d\u80fd\u4fdd\u8bc1\u6d88\u606f\u6267\u884c\u987a\u5e8f\u3002 \u6709\u4e00\u5e27\u7684\u5ef6\u8fdf\u3002","title":"\u95ee\u9898"},{"location":"Function/Gameplay/GameplayBasics/#_4","text":"","title":"\u811a\u672c\u7cfb\u7edf"},{"location":"Function/Gameplay/GameplayBasics/#_5","text":"\u7c7b\u4f3c\u4e8e Unity \uff0c\u901a\u8fc7\u811a\u672c\u6269\u5145 Component \u529f\u80fd\u3002","title":"\u5f15\u64ce\u8c03\u7528\u811a\u672c"},{"location":"Function/Gameplay/GameplayBasics/#_6","text":"\u5c06\u5f15\u64ce\u89c6\u4e3a SDK \uff0c\u66b4\u9732\u63a5\u53e3\u4f9b\u811a\u672c\u8c03\u7528\u3002","title":"\u811a\u672c\u8c03\u7528\u5f15\u64ce"},{"location":"Function/Gameplay/GameplayBasics/#_7","text":"\u5e76\u4e0d\u60f3\u63d0\u592a\u591a\u53ef\u89c6\u5316\u811a\u672c\u7684\u4e8b\u60c5\uff0c\u6d89\u53ca\u5230\u4e86\u53cd\u5c04\u5b8f\uff08\u7c7b\u4f3c\u4e8e UE \u5c06\u4ee3\u7801\u53cd\u5c04\u5230\u84dd\u56fe\u4e2d\uff09\u3002","title":"\u53ef\u89c6\u5316\u811a\u672c"},{"location":"Function/Gameplay/GameplayBasics/#3c","text":"Character\uff1b Control\uff1b Camera\u3002","title":"3C"}]}